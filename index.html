<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a66c2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Mini Sudoku">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%230a66c2'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='280' fill='white' font-family='Arial'>6√ó6</text></svg>">
    <title>Mini Sudoku 6√ó6</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #f3f2ef;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 420px;
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        /* Top bar */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 8px;
        }

        .top-bar h1 {
            font-size: 18px;
            font-weight: 600;
            color: #000;
        }

        .top-bar-center {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: #666;
        }

        .top-bar-center .timer {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .settings-btn:active {
            background: #f5f5f5;
        }

        .menu-btn {
            padding: 6px;
            border: none;
            background: transparent;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        /* Grid */
        .grid-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            min-height: 0;
        }

        .sudoku-grid {
            display: inline-grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0;
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
            background: #444;
            transition: filter 0.3s ease;
        }

        .sudoku-grid.blurred {
            filter: blur(8px);
            pointer-events: none;
        }

        .cell {
            width: 52px;
            height: 52px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 500;
            cursor: pointer;
            position: relative;
            border: 0.5px solid #ccc;
            user-select: none;
            touch-action: manipulation;
        }

        .cell:active {
            background: #f0f0f0;
        }

        .cell.given {
            color: #000;
            background: white;
            font-weight: 600;
            cursor: default;
        }

        .cell.given.selected {
            box-shadow: inset 0 0 0 2px #00000040;
        }

        .cell.user-input {
            color: #666;
            font-weight: 500;
        }

        .cell.selected {
            background: #e8f0fe !important;
            box-shadow: inset 0 0 0 2px #1a73e8;
        }

        .cell.highlighted {
            background: #fff4cc;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { background: #fff4cc; }
            50% { background: #ffe999; }
        }

        .cell.complete-flash {
            animation: complete-flash 0.6s ease-out;
        }

        @keyframes complete-flash {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.given.complete-flash {
            animation: complete-flash-given 0.6s ease-out;
        }

        @keyframes complete-flash-given {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.user-input.complete-flash {
            animation: complete-flash-user 0.6s ease-out;
        }

        @keyframes complete-flash-user {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.error {
            background: #fee !important;
            color: #c00 !important;
        }

        /* 2√ó3 block borders */
        .cell:nth-child(3),
        .cell:nth-child(9),
        .cell:nth-child(15),
        .cell:nth-child(21),
        .cell:nth-child(27),
        .cell:nth-child(33) {
            border-right: 2px solid #444;
        }

        .cell:nth-child(7),
        .cell:nth-child(8),
        .cell:nth-child(9),
        .cell:nth-child(10),
        .cell:nth-child(11),
        .cell:nth-child(12) {
            border-bottom: 2px solid #444;
        }

        .cell:nth-child(19),
        .cell:nth-child(20),
        .cell:nth-child(21),
        .cell:nth-child(22),
        .cell:nth-child(23),
        .cell:nth-child(24) {
            border-bottom: 2px solid #444;
        }

        .notes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
            padding: 3px;
        }

        .note {
            font-size: 11px;
            color: #00000066;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 400;
        }

        /* Action buttons */
        .action-bar {
            display: flex;
            justify-content: center;
            gap: 32px;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #666;
            font-size: 12px;
            font-weight: 500;
        }

        .action-btn:active {
            opacity: 0.7;
        }

        .action-btn.active {
            color: #1a73e8;
        }

        .action-btn .icon {
            font-size: 20px;
        }

        /* Number pad */
        .number-pad {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px 0;
            padding-bottom: 48px;
        }

        .number-btn {
            padding: 16px;
            font-size: 22px;
            font-weight: 500;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            color: #000;
            cursor: pointer;
            transition: all 0.15s;
        }

        .number-btn:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }

        .number-btn.action {
            font-size: 12px;
            color: #666;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .number-btn.action .icon {
            font-size: 18px;
        }

        /* Message */
        .message {
            padding: 10px 16px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.4;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.info {
            background: #e8f4fd;
            color: #0c5460;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .modal-section {
            margin-bottom: 16px;
        }

        .modal-section label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .option-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            background: white;
            color: #333;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .option-btn.active {
            border-color: #1a73e8;
            background: #e8f0fe;
            color: #1a73e8;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .modal-btn.primary {
            background: #1a73e8;
            color: white;
        }

        .modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .stats-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f8f8f8;
            border-radius: 6px;
            font-size: 13px;
        }

        .stat-row .label {
            color: #333;
            font-weight: 500;
        }

        .stat-row .value {
            color: #666;
        }

        .stat-row .count {
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .stats-empty {
            color: #999;
            font-size: 13px;
            text-align: center;
            padding: 12px;
        }

        .stats-chart {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .stats-chart svg {
            width: 100%;
            height: auto;
        }

        .chart-summary {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            padding: 0 4px;
        }

        .chart-summary .stat {
            text-align: center;
        }

        .chart-summary .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .chart-summary .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #999;
        }

        .new-game-btn {
            display: none;
            width: 100%;
            padding: 14px;
            margin-top: 8px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .new-game-btn.show {
            display: block;
        }

        .new-game-btn:active {
            background: #1557b0;
        }

        /* Responsive */
        @media (max-width: 360px) {
            .cell {
                width: 46px;
                height: 46px;
                font-size: 22px;
            }
        }

        @media (min-width: 400px) {
            .cell {
                width: 56px;
                height: 56px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1>Mini Sudoku</h1>
            <div class="top-bar-center">
                <div class="timer">
                    <span>‚è±</span>
                    <span id="timer">0:00</span>
                </div>
            </div>
            <div class="top-bar-right">
                <button class="menu-btn" onclick="app.openStats()" title="Stats">üìä</button>
                <button class="settings-btn" onclick="app.openSettings()">
                    Settings <span>‚ñæ</span>
                </button>
                <button class="menu-btn" onclick="app.newPuzzle()">‚ü≥</button>
            </div>
        </div>

        <!-- Install Banner (hidden by default) -->
        <div id="installBanner" style="display: none; background: #e8f4fd; border-radius: 8px; padding: 10px; margin-bottom: 8px; text-align: center;">
            <div style="font-size: 12px; color: #1a73e8;" id="installInstructions"></div>
            <button style="margin-top: 6px; padding: 4px 12px; border: none; background: #1a73e8; color: white; border-radius: 4px; font-size: 12px; cursor: pointer;" onclick="app.dismissInstallBanner()">Got it</button>
        </div>

        <!-- Message area -->
        <div id="message" style="display: none;"></div>
        <button class="new-game-btn" id="newGameBtn" onclick="app.newPuzzle()">New Game</button>

        <!-- Grid -->
        <div class="grid-wrapper">
            <div class="sudoku-grid" id="grid"></div>
        </div>

        <!-- Action Bar -->
        <div class="action-bar">
            <button class="action-btn" onclick="app.getHint()">
                <span class="icon">üí°</span>
                <span>Hint</span>
            </button>
            <button class="action-btn" id="notesBtn" onclick="app.toggleNotes()">
                <span class="icon">‚úèÔ∏è</span>
                <span>Notes <span id="notesStatus">OFF</span></span>
            </button>
        </div>

        <!-- Number Pad -->
        <div class="number-pad">
            <button class="number-btn" onclick="app.inputNumber(1)">1</button>
            <button class="number-btn" onclick="app.inputNumber(2)">2</button>
            <button class="number-btn" onclick="app.inputNumber(3)">3</button>
            <button class="number-btn action" onclick="app.clearCell()">
                <span class="icon">‚úï</span>
                <span>Erase</span>
            </button>
            <button class="number-btn" onclick="app.inputNumber(4)">4</button>
            <button class="number-btn" onclick="app.inputNumber(5)">5</button>
            <button class="number-btn" onclick="app.inputNumber(6)">6</button>
            <button class="number-btn action" onclick="app.undo()">
                <span class="icon">‚Ü∫</span>
                <span>Undo</span>
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal" onclick="app.closeStatsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 360px;">
            <h2>Stats</h2>

            <div class="modal-section">
                <label>Filter by Difficulty</label>
                <div class="option-group" id="statsFilterOptions">
                    <button class="option-btn active" data-value="all" onclick="app.filterStats('all')">All</button>
                    <button class="option-btn" data-value="easy" onclick="app.filterStats('easy')">Easy</button>
                    <button class="option-btn" data-value="medium" onclick="app.filterStats('medium')">Medium</button>
                    <button class="option-btn" data-value="hard" onclick="app.filterStats('hard')">Hard</button>
                    <button class="option-btn" data-value="expert" onclick="app.filterStats('expert')">Expert</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Solve Time Progress</label>
                <div id="statsChart" class="stats-chart">
                    <svg id="chartSvg" viewBox="0 0 320 160"></svg>
                </div>
                <div id="chartSummary" class="chart-summary"></div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.resetStats()">Reset</button>
                <button class="modal-btn primary" onclick="app.closeStats()">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal" onclick="app.closeSettingsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <h2>Settings</h2>

            <div class="modal-section">
                <label>Difficulty</label>
                <div class="option-group" id="difficultyOptions">
                    <button class="option-btn" data-value="easy">Easy</button>
                    <button class="option-btn active" data-value="medium">Medium</button>
                    <button class="option-btn" data-value="hard">Hard</button>
                    <button class="option-btn" data-value="expert">Expert</button>
                    <button class="option-btn" data-value="ultra">Ultra</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Hint Detail</label>
                <div class="option-group" id="hintOptions">
                    <button class="option-btn" data-value="strategy">Strategy Only</button>
                    <button class="option-btn" data-value="location">+ Location</button>
                    <button class="option-btn active" data-value="full">Full Hint</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Timer</label>
                <div class="option-group">
                    <button class="option-btn" id="timerToggleBtn" onclick="app.toggleTimer()">
                        <span id="timerBtnText">Pause</span>
                    </button>
                </div>
            </div>

            <div class="modal-section">
                <label>Actions</label>
                <div class="option-group">
                    <button class="option-btn" onclick="app.applyHintFromSettings()">Apply Hint</button>
                    <button class="option-btn" onclick="app.solveAllFromSettings()">Solve All</button>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.closeSettings()">Close</button>
                <button class="modal-btn primary" onclick="app.newPuzzleFromSettings()">New Puzzle</button>
            </div>
        </div>
    </div>

    <script>
        const app = {
            grid: [],
            solution: [],
            initialGrid: [],
            selectedCell: null,
            mode: 'normal',
            notes: {},
            timer: 0,
            timerInterval: null,
            isRunning: true,
            hintLevel: 'full',
            currentHint: null,
            highlightedCells: [],
            history: [], // For undo functionality
            difficulty: 'medium',

            // Stats tracking
            stats: {
                gamesByDifficulty: {},  // { 'easy': [{time: 120, date: ...}, ...], ... }
            },
            statsFilter: 'all',

            init() {
                this.loadStats();
                this.initSettingsListeners();
                this.newPuzzle();
            },

            loadStats() {
                try {
                    const saved = localStorage.getItem('sudokuStats');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        this.stats = {
                            gamesByDifficulty: parsed.gamesByDifficulty || {}
                        };
                    }
                } catch (e) {
                    console.error('Failed to load stats:', e);
                    this.stats = { gamesByDifficulty: {} };
                }
            },

            saveStats() {
                try {
                    localStorage.setItem('sudokuStats', JSON.stringify(this.stats));
                } catch (e) {
                    console.error('Failed to save stats:', e);
                }
            },

            trackGameComplete(difficulty, time) {
                if (!this.stats.gamesByDifficulty[difficulty]) {
                    this.stats.gamesByDifficulty[difficulty] = [];
                }
                this.stats.gamesByDifficulty[difficulty].push({
                    time,
                    date: new Date().toISOString()
                });
                // Keep only last 50 games per difficulty
                if (this.stats.gamesByDifficulty[difficulty].length > 50) {
                    this.stats.gamesByDifficulty[difficulty].shift();
                }
                this.saveStats();
            },

            getAverageTime(difficulty) {
                const games = this.stats.gamesByDifficulty[difficulty];
                if (!games || games.length === 0) return null;
                const total = games.reduce((sum, g) => sum + g.time, 0);
                return Math.round(total / games.length);
            },

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            openStats() {
                this.statsFilter = 'all';
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
                document.getElementById('statsModal').classList.add('show');
            },

            closeStats() {
                document.getElementById('statsModal').classList.remove('show');
            },

            closeStatsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeStats();
                }
            },

            resetStats() {
                if (confirm('Reset all stats? This cannot be undone.')) {
                    this.stats = { gamesByDifficulty: {} };
                    this.saveStats();
                    this.updateStatsDisplay();
                }
            },

            filterStats(difficulty) {
                this.statsFilter = difficulty;
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
            },

            updateStatsFilterUI() {
                document.querySelectorAll('#statsFilterOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.statsFilter);
                });
            },

            getFilteredGames() {
                const difficulties = this.statsFilter === 'all'
                    ? ['easy', 'medium', 'hard', 'expert', 'ultra']
                    : [this.statsFilter];

                let games = [];
                difficulties.forEach(diff => {
                    const diffGames = this.stats.gamesByDifficulty[diff] || [];
                    diffGames.forEach((g, i) => {
                        games.push({ ...g, difficulty: diff, index: i });
                    });
                });

                // Sort by date
                games.sort((a, b) => new Date(a.date) - new Date(b.date));
                return games;
            },

            updateStatsDisplay() {
                const games = this.getFilteredGames();
                const svg = document.getElementById('chartSvg');
                const summary = document.getElementById('chartSummary');

                if (games.length === 0) {
                    svg.innerHTML = '<text x="160" y="85" text-anchor="middle" fill="#999" font-size="13">No games completed yet</text>';
                    summary.innerHTML = '';
                    return;
                }

                // Chart dimensions
                const width = 320;
                const height = 160;
                const padding = { top: 20, right: 20, bottom: 30, left: 45 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                // Calculate scales
                const times = games.map(g => g.time);
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                const timeRange = maxTime - minTime || 60;
                const yMin = Math.max(0, minTime - timeRange * 0.1);
                const yMax = maxTime + timeRange * 0.1;

                const xScale = (i) => padding.left + (i / (games.length - 1 || 1)) * chartWidth;
                const yScale = (t) => padding.top + chartHeight - ((t - yMin) / (yMax - yMin)) * chartHeight;

                // Build SVG
                let svgContent = '';

                // Y-axis labels
                const yTicks = 4;
                for (let i = 0; i <= yTicks; i++) {
                    const val = yMin + (yMax - yMin) * (i / yTicks);
                    const y = yScale(val);
                    svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>`;
                    svgContent += `<text x="${padding.left - 5}" y="${y + 4}" text-anchor="end" fill="#999" font-size="10">${this.formatTime(Math.round(val))}</text>`;
                }

                // X-axis
                svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="#ccc" stroke-width="1"/>`;
                svgContent += `<text x="${width / 2}" y="${height - 8}" text-anchor="middle" fill="#999" font-size="10">Games (${games.length})</text>`;

                // Line path
                if (games.length > 1) {
                    let pathD = `M ${xScale(0)} ${yScale(games[0].time)}`;
                    for (let i = 1; i < games.length; i++) {
                        pathD += ` L ${xScale(i)} ${yScale(games[i].time)}`;
                    }
                    svgContent += `<path d="${pathD}" fill="none" stroke="#1a73e8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                }

                // Points
                const diffColors = { easy: '#10b981', medium: '#f59e0b', hard: '#ef4444', expert: '#8b5cf6', ultra: '#ec4899' };
                games.forEach((g, i) => {
                    const color = diffColors[g.difficulty] || '#1a73e8';
                    svgContent += `<circle cx="${xScale(i)}" cy="${yScale(g.time)}" r="4" fill="${color}" stroke="white" stroke-width="1.5"/>`;
                });

                svg.innerHTML = svgContent;

                // Summary stats
                const avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                const bestTime = Math.min(...times);
                const latestTime = times[times.length - 1];

                summary.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(bestTime)}</div>
                        <div class="stat-label">Best</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(avgTime)}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(latestTime)}</div>
                        <div class="stat-label">Latest</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${games.length}</div>
                        <div class="stat-label">Games</div>
                    </div>
                `;
            },

            isValid(grid, row, col, num) {
                for (let x = 0; x < 6; x++) {
                    if (grid[row][x] === num) return false;
                    if (grid[x][col] === num) return false;
                }
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[boxRow + i][boxCol + j] === num) return false;
                    }
                }
                return true;
            },

            solve(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (this.solve(grid)) return true;
                                    grid[row][col] = 0;
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            },

            // Count solutions (stops at 2 since we only need to know if unique)
            countSolutions(grid, count = { value: 0 }) {
                if (count.value >= 2) return count.value; // Early exit if multiple found

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    this.countSolutions(grid, count);
                                    grid[row][col] = 0;
                                    if (count.value >= 2) return count.value;
                                }
                            }
                            return count.value;
                        }
                    }
                }
                count.value++;
                return count.value;
            },

            hasUniqueSolution(grid) {
                const gridCopy = grid.map(row => [...row]);
                return this.countSolutions(gridCopy) === 1;
            },

            generatePuzzle(difficulty = 'medium') {
                const grid = Array(6).fill(null).map(() => Array(6).fill(0));

                // Fill the first row with random numbers
                const firstRow = [1, 2, 3, 4, 5, 6].sort(() => Math.random() - 0.5);
                for (let col = 0; col < 6; col++) {
                    grid[0][col] = firstRow[col];
                }

                // Solve the rest
                this.solve(grid);
                const solution = grid.map(row => [...row]);

                const cellsToRemove = {
                    easy: 12,      // More clues = easier
                    medium: 18,    // Moderate clues
                    hard: 22,      // Fewer clues = harder
                    expert: 24,    // Very few clues
                    ultra: 27      // Extreme - requires X-Wing, Y-Wing, BUG
                }[difficulty] || 18;

                // Collect all cell positions and shuffle them
                const positions = [];
                for (let r = 0; r < 6; r++) {
                    for (let c = 0; c < 6; c++) {
                        positions.push([r, c]);
                    }
                }
                // Shuffle positions randomly
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                let removed = 0;

                // Try to remove cells while maintaining unique solution
                for (const [row, col] of positions) {
                    if (removed >= cellsToRemove) break;

                    const backup = grid[row][col];
                    grid[row][col] = 0;

                    // Check if puzzle still has unique solution
                    if (this.hasUniqueSolution(grid)) {
                        removed++;
                    } else {
                        // Restore the cell - removing it creates multiple solutions
                        grid[row][col] = backup;
                    }
                }

                console.log(`Generated ${difficulty} puzzle: removed ${removed}/${cellsToRemove} cells (unique solution guaranteed)`);
                return { puzzle: grid, solution };
            },

            getCandidates(grid, row, col) {
                if (grid[row][col] !== 0) return [];
                const candidates = [];
                for (let num = 1; num <= 6; num++) {
                    if (this.isValid(grid, row, col, num)) {
                        candidates.push(num);
                    }
                }
                return candidates;
            },

            findNakedSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            if (candidates.length === 1) {
                                return {
                                    type: 'Naked Single',
                                    row, col,
                                    value: candidates[0],
                                    explanation: `Cell (${row + 1}, ${col + 1}) can only be ${candidates[0]}. All other numbers are eliminated by existing numbers in its row, column, and box.`,
                                    cells: [[row, col]]
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findHiddenSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(col);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Row)',
                                row, col: positions[0],
                                value: num,
                                explanation: `In row ${row + 1}, the number ${num} can only go in column ${positions[0] + 1}.`,
                                cells: [[row, positions[0]]]
                            };
                        }
                    }
                }

                for (let col = 0; col < 6; col++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(row);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Column)',
                                row: positions[0], col,
                                value: num,
                                explanation: `In column ${col + 1}, the number ${num} can only go in row ${positions[0] + 1}.`,
                                cells: [[positions[0], col]]
                            };
                        }
                    }
                }

                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 3) * 2;
                    const boxCol = (boxIdx % 3) * 3;
                    
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Box)',
                                row: positions[0][0], col: positions[0][1],
                                value: num,
                                explanation: `In box (${Math.floor(boxIdx / 3) + 1}, ${(boxIdx % 3) + 1}), the number ${num} can only go in one position.`,
                                cells: positions
                            };
                        }
                    }
                }
                return null;
            },

            getSmartHint(grid) {
                // Basic techniques (all difficulties)
                let hint = this.findNakedSingle(grid);
                if (hint) return hint;

                hint = this.findHiddenSingle(grid);
                if (hint) return hint;

                // Intermediate techniques (medium+)
                if (this.difficulty !== 'easy') {
                    hint = this.findNakedPair(grid);
                    if (hint) return hint;

                    hint = this.findPointingPair(grid);
                    if (hint) return hint;

                    hint = this.findBoxLineReduction(grid);
                    if (hint) return hint;
                }

                // Advanced techniques (hard+)
                if (this.difficulty === 'hard' || this.difficulty === 'expert' || this.difficulty === 'ultra') {
                    hint = this.findXWing(grid);
                    if (hint) return hint;
                }

                // Expert techniques
                if (this.difficulty === 'expert' || this.difficulty === 'ultra') {
                    hint = this.findYWing(grid);
                    if (hint) return hint;
                }

                // Ultra expert techniques
                if (this.difficulty === 'ultra') {
                    hint = this.findBUG(grid);
                    if (hint) return hint;

                    hint = this.findSwordfish(grid);
                    if (hint) return hint;
                }

                // Fallback
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            const difficultyHints = {
                                'expert': ' Try X-Wing or Y-Wing patterns.',
                                'ultra': ' Try BUG, Swordfish, or advanced chains.'
                            };
                            return {
                                type: 'General Hint',
                                row, col,
                                value: null,
                                explanation: `Cell (${row + 1}, ${col + 1}) has ${candidates.length} candidates: ${candidates.join(', ')}.${difficultyHints[this.difficulty] || ''}`,
                                cells: [[row, col]]
                            };
                        }
                    }
                }
                return null;
            },

            findNakedPair(grid) {
                const allCandidates = {};
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            allCandidates[`${row}-${col}`] = this.getCandidates(grid, row, col);
                        }
                    }
                }
                
                // Check rows
                for (let row = 0; row < 6; row++) {
                    const cellsInRow = [];
                    for (let col = 0; col < 6; col++) {
                        const key = `${row}-${col}`;
                        if (allCandidates[key] && allCandidates[key].length === 2) {
                            cellsInRow.push({ col, candidates: allCandidates[key] });
                        }
                    }
                    
                    for (let i = 0; i < cellsInRow.length; i++) {
                        for (let j = i + 1; j < cellsInRow.length; j++) {
                            const c1 = cellsInRow[i].candidates;
                            const c2 = cellsInRow[j].candidates;
                            if (c1[0] === c2[0] && c1[1] === c2[1]) {
                                return {
                                    type: 'Naked Pair',
                                    explanation: `Row ${row + 1} has a naked pair [${c1[0]}, ${c1[1]}] in columns ${cellsInRow[i].col + 1} and ${cellsInRow[j].col + 1}. These numbers can be eliminated from other cells in this row.`,
                                    cells: [[row, cellsInRow[i].col], [row, cellsInRow[j].col]],
                                    values: c1
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findPointingPair(grid) {
                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 2) * 2;
                    const boxCol = (boxIdx % 2) * 3;
                    
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }
                        
                        if (positions.length >= 2 && positions.length <= 3) {
                            const sameRow = positions.every(([r]) => r === positions[0][0]);
                            if (sameRow) {
                                return {
                                    type: 'Pointing Pair',
                                    explanation: `In box at (${boxRow + 1}, ${boxCol + 1}), number ${num} only appears in row ${positions[0][0] + 1}. Eliminates ${num} from other cells in that row.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                            
                            const sameCol = positions.every(([, c]) => c === positions[0][1]);
                            if (sameCol) {
                                return {
                                    type: 'Pointing Pair',
                                    explanation: `In box at (${boxRow + 1}, ${boxCol + 1}), number ${num} only appears in column ${positions[0][1] + 1}. Eliminates ${num} from other cells in that column.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findBoxLineReduction(grid) {
                for (let num = 1; num <= 6; num++) {
                    for (let row = 0; row < 6; row++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push([row, col]);
                            }
                        }
                        
                        if (positions.length >= 2) {
                            const boxCols = positions.map(([, c]) => Math.floor(c / 3));
                            if (boxCols.every(bc => bc === boxCols[0])) {
                                return {
                                    type: 'Box/Line Reduction',
                                    explanation: `In row ${row + 1}, number ${num} only appears in one box. Eliminates ${num} from other cells in that box.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findXWing(grid) {
                for (let num = 1; num <= 6; num++) {
                    const rowPairs = [];
                    
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                cols.push(col);
                            }
                        }
                        if (cols.length === 2) {
                            rowPairs.push({ row, cols });
                        }
                    }
                    
                    for (let i = 0; i < rowPairs.length; i++) {
                        for (let j = i + 1; j < rowPairs.length; j++) {
                            if (rowPairs[i].cols[0] === rowPairs[j].cols[0] && 
                                rowPairs[i].cols[1] === rowPairs[j].cols[1]) {
                                return {
                                    type: 'X-Wing',
                                    explanation: `X-Wing: ${num} appears exactly twice in rows ${rowPairs[i].row + 1} and ${rowPairs[j].row + 1}, both in columns ${rowPairs[i].cols[0] + 1} and ${rowPairs[i].cols[1] + 1}. Eliminates ${num} from other cells in those columns.`,
                                    cells: [
                                        [rowPairs[i].row, rowPairs[i].cols[0]],
                                        [rowPairs[i].row, rowPairs[i].cols[1]],
                                        [rowPairs[j].row, rowPairs[j].cols[0]],
                                        [rowPairs[j].row, rowPairs[j].cols[1]]
                                    ],
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findYWing(grid) {
                const allCandidates = {};
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) {
                                allCandidates[`${row}-${col}`] = { row, col, cands };
                            }
                        }
                    }
                }
                
                const biValueCells = Object.values(allCandidates);
                
                for (let i = 0; i < biValueCells.length; i++) {
                    const pivot = biValueCells[i];
                    for (let j = 0; j < biValueCells.length; j++) {
                        if (i === j) continue;
                        const wing1 = biValueCells[j];
                        
                        const sharedWithPivot = pivot.cands.filter(c => wing1.cands.includes(c));
                        if (sharedWithPivot.length !== 1) continue;
                        
                        for (let k = 0; k < biValueCells.length; k++) {
                            if (k === i || k === j) continue;
                            const wing2 = biValueCells[k];
                            
                            const sharedWithPivot2 = pivot.cands.filter(c => wing2.cands.includes(c));
                            if (sharedWithPivot2.length !== 1) continue;
                            if (sharedWithPivot2[0] === sharedWithPivot[0]) continue;
                            
                            const sharedBetweenWings = wing1.cands.filter(c => wing2.cands.includes(c));
                            if (sharedBetweenWings.length === 1) {
                                return {
                                    type: 'Y-Wing',
                                    explanation: `Y-Wing: Pivot at (${pivot.row + 1}, ${pivot.col + 1}) [${pivot.cands.join(',')}] connects two wings. Eliminates ${sharedBetweenWings[0]} from cells seeing both wings.`,
                                    cells: [
                                        [pivot.row, pivot.col],
                                        [wing1.row, wing1.col],
                                        [wing2.row, wing2.col]
                                    ],
                                    value: sharedBetweenWings[0]
                                };
                            }
                        }
                    }
                }
                return null;
            },

            // BUG (Bivalue Universal Grave) - if all unsolved cells have 2 candidates
            // except one cell with 3, that cell's value is the candidate appearing 3 times
            findBUG(grid) {
                const cellCandidates = [];
                let triValueCell = null;

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) {
                                cellCandidates.push({ row, col, cands });
                            } else if (cands.length === 3) {
                                if (triValueCell) return null; // More than one 3-candidate cell
                                triValueCell = { row, col, cands };
                            } else {
                                return null; // Cell with 1 or 4+ candidates breaks BUG pattern
                            }
                        }
                    }
                }

                if (!triValueCell) return null;

                // Find which candidate appears 3 times in row/col/box
                for (const cand of triValueCell.cands) {
                    // Count occurrences in row
                    let rowCount = 0;
                    for (let c = 0; c < 6; c++) {
                        if (grid[triValueCell.row][c] === 0) {
                            const cellCands = this.getCandidates(grid, triValueCell.row, c);
                            if (cellCands.includes(cand)) rowCount++;
                        }
                    }

                    // Count occurrences in column
                    let colCount = 0;
                    for (let r = 0; r < 6; r++) {
                        if (grid[r][triValueCell.col] === 0) {
                            const cellCands = this.getCandidates(grid, r, triValueCell.col);
                            if (cellCands.includes(cand)) colCount++;
                        }
                    }

                    // In a BUG, each candidate appears exactly twice in each unit
                    // The solution is the candidate that appears 3 times (odd count)
                    if (rowCount % 2 === 1 || colCount % 2 === 1) {
                        return {
                            type: 'BUG (Bivalue Universal Grave)',
                            row: triValueCell.row,
                            col: triValueCell.col,
                            value: cand,
                            explanation: `BUG detected! All cells have 2 candidates except (${triValueCell.row + 1}, ${triValueCell.col + 1}) with 3. The answer is ${cand} (appears odd number of times in its units).`,
                            cells: [[triValueCell.row, triValueCell.col]]
                        };
                    }
                }
                return null;
            },

            // Swordfish - like X-Wing but with 3 rows/columns
            findSwordfish(grid) {
                for (let num = 1; num <= 6; num++) {
                    // Find rows where num appears in exactly 2-3 positions
                    const rowData = [];
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                cols.push(col);
                            }
                        }
                        if (cols.length >= 2 && cols.length <= 3) {
                            rowData.push({ row, cols });
                        }
                    }

                    // Need at least 3 rows for Swordfish
                    if (rowData.length >= 3) {
                        // Try all combinations of 3 rows
                        for (let i = 0; i < rowData.length - 2; i++) {
                            for (let j = i + 1; j < rowData.length - 1; j++) {
                                for (let k = j + 1; k < rowData.length; k++) {
                                    const allCols = new Set([
                                        ...rowData[i].cols,
                                        ...rowData[j].cols,
                                        ...rowData[k].cols
                                    ]);
                                    // Swordfish: 3 rows share exactly 3 columns
                                    if (allCols.size === 3) {
                                        return {
                                            type: 'Swordfish',
                                            explanation: `Swordfish: ${num} in rows ${rowData[i].row + 1}, ${rowData[j].row + 1}, ${rowData[k].row + 1} is confined to columns ${[...allCols].map(c => c + 1).join(', ')}. Eliminates ${num} from other cells in those columns.`,
                                            cells: [
                                                ...rowData[i].cols.map(c => [rowData[i].row, c]),
                                                ...rowData[j].cols.map(c => [rowData[j].row, c]),
                                                ...rowData[k].cols.map(c => [rowData[k].row, c])
                                            ],
                                            value: num
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                return null;
            },

            newPuzzle() {
                const { puzzle, solution } = this.generatePuzzle(this.difficulty);

                // Verify the puzzle is valid
                console.log('Generated puzzle:', puzzle);
                console.log('Solution:', solution);
                console.log('Difficulty:', this.difficulty);
                
                this.grid = puzzle.map(row => [...row]);
                this.initialGrid = puzzle.map(row => [...row]);
                this.solution = solution;
                this.selectedCell = null;
                this.notes = {};
                this.history = [];
                this.timer = 0;
                this.isRunning = true;
                this.currentHint = null;
                this.highlightedCells = [];
                this.startTimer();
                this.render();
                this.hideMessage();
                this.updateTimerButton();
                document.getElementById('newGameBtn').classList.remove('show');
            },

            changeDifficulty(newDifficulty) {
                this.difficulty = newDifficulty;
                this.updateSettingsUI();
            },

            // Settings Modal
            openSettings() {
                this.updateSettingsUI();
                document.getElementById('settingsModal').classList.add('show');
            },

            closeSettings() {
                document.getElementById('settingsModal').classList.remove('show');
            },

            closeSettingsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeSettings();
                }
            },

            newPuzzleFromSettings() {
                this.closeSettings();
                this.newPuzzle();
            },

            updateSettingsUI() {
                // Update difficulty buttons
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.difficulty);
                });
                // Update hint buttons
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.hintLevel);
                });
                // Update timer button
                this.updateTimerButton();
            },

            updateTimerButton() {
                const btn = document.getElementById('timerToggleBtn');
                const text = document.getElementById('timerBtnText');
                if (btn && text) {
                    text.textContent = this.isRunning ? 'Pause' : 'Resume';
                    btn.classList.toggle('active', !this.isRunning);
                }
            },

            initSettingsListeners() {
                // Difficulty options
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.changeDifficulty(btn.dataset.value);
                    });
                });
                // Hint options
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setHintLevel(btn.dataset.value);
                    });
                });
            },

            startTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if (this.isRunning) {
                        this.timer++;
                        this.updateTimer();
                    }
                }, 1000);
            },

            toggleTimer() {
                this.isRunning = !this.isRunning;
                this.updateTimerButton();

                // Add/remove blur effect
                const grid = document.getElementById('grid');
                if (this.isRunning) {
                    grid.classList.remove('blurred');
                } else {
                    grid.classList.add('blurred');
                }
            },

            updateTimer() {
                const mins = Math.floor(this.timer / 60);
                const secs = this.timer % 60;
                document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            toggleNotes() {
                this.mode = this.mode === 'normal' ? 'notes' : 'normal';
                const notesBtn = document.getElementById('notesBtn');
                const notesStatus = document.getElementById('notesStatus');
                if (this.mode === 'notes') {
                    notesBtn.classList.add('active');
                    if (notesStatus) notesStatus.textContent = 'ON';
                } else {
                    notesBtn.classList.remove('active');
                    if (notesStatus) notesStatus.textContent = 'OFF';
                }
            },

            setHintLevel(level) {
                this.hintLevel = level;
                this.updateSettingsUI();
            },

            selectCell(row, col) {
                this.selectedCell = [row, col];
                this.render();
            },

            checkUnitComplete(row, col) {
                // Check if a row matches the solution
                const checkRow = (r) => {
                    for (let c = 0; c < 6; c++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a column matches the solution
                const checkCol = (c) => {
                    for (let r = 0; r < 6; r++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a box matches the solution
                const checkBox = (r, c) => {
                    const boxRow = Math.floor(r / 2) * 2;
                    const boxCol = Math.floor(c / 3) * 3;
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 3; j++) {
                            const br = boxRow + i;
                            const bc = boxCol + j;
                            if (this.grid[br][bc] !== this.solution[br][bc]) return false;
                        }
                    }
                    return true;
                };

                const completedUnits = [];

                // Check row
                if (checkRow(row)) {
                    completedUnits.push({ type: 'row', index: row });
                }

                // Check column
                if (checkCol(col)) {
                    completedUnits.push({ type: 'col', index: col });
                }

                // Check box
                if (checkBox(row, col)) {
                    const boxRow = Math.floor(row / 2) * 2;
                    const boxCol = Math.floor(col / 3) * 3;
                    completedUnits.push({ type: 'box', boxRow, boxCol });
                }

                // Animate completed units
                if (completedUnits.length > 0) {
                    this.animateCompletions(completedUnits);
                }
            },

            animateCompletions(units) {
                const cells = document.querySelectorAll('.cell');
                
                units.forEach(unit => {
                    if (unit.type === 'row') {
                        // Animate entire row
                        for (let col = 0; col < 6; col++) {
                            const cellIndex = unit.index * 6 + col;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'col') {
                        // Animate entire column
                        for (let row = 0; row < 6; row++) {
                            const cellIndex = row * 6 + unit.index;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'box') {
                        // Animate entire box
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = unit.boxRow + i;
                                const col = unit.boxCol + j;
                                const cellIndex = row * 6 + col;
                                cells[cellIndex].classList.add('complete-flash');
                                setTimeout(() => {
                                    cells[cellIndex].classList.remove('complete-flash');
                                }, 600);
                            }
                        }
                    }
                });
            },

            inputNumber(num) {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                if (this.mode === 'normal') {
                    // Save to history for undo
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: num,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });

                    this.grid[row][col] = num;
                    delete this.notes[`${row}-${col}`];
                    this.render();
                    
                    // Check for completed units AFTER rendering
                    setTimeout(() => {
                        this.checkUnitComplete(row, col);
                        this.checkComplete();
                    }, 50);
                } else {
                    const key = `${row}-${col}`;
                    const cellNotes = this.notes[key] || [];
                    if (cellNotes.includes(num)) {
                        this.notes[key] = cellNotes.filter(n => n !== num);
                        if (this.notes[key].length === 0) delete this.notes[key];
                    } else {
                        this.notes[key] = [...cellNotes, num].sort();
                    }
                    this.render();
                }
            },

            undo() {
                if (this.history.length === 0) {
                    this.showMessage('Nothing to undo', 'info');
                    setTimeout(() => this.hideMessage(), 1500);
                    return;
                }

                const lastMove = this.history.pop();
                this.grid[lastMove.row][lastMove.col] = lastMove.oldValue;
                
                if (lastMove.oldNotes) {
                    this.notes[`${lastMove.row}-${lastMove.col}`] = lastMove.oldNotes;
                } else {
                    delete this.notes[`${lastMove.row}-${lastMove.col}`];
                }

                this.selectedCell = [lastMove.row, lastMove.col];
                this.render();
            },

            clearCell() {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                // Save to history for undo
                if (this.grid[row][col] !== 0) {
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: 0,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });
                }

                this.grid[row][col] = 0;
                delete this.notes[`${row}-${col}`];
                this.render();
            },

            getHint() {
                const hint = this.getSmartHint(this.grid);
                if (!hint) {
                    this.showMessage('No hints available!', 'info');
                    return;
                }

                this.currentHint = hint;
                this.highlightedCells = hint.cells || [];

                let message = '';
                if (this.hintLevel === 'strategy') {
                    message = `üí° Try: ${hint.type}`;
                } else if (this.hintLevel === 'location') {
                    message = `üí° ${hint.type}: Look at row ${hint.row + 1}, column ${hint.col + 1}`;
                } else {
                    message = `üí° ${hint.type}: ${hint.explanation}`;
                }

                this.showMessage(message, 'info');
                this.render();

                setTimeout(() => {
                    this.highlightedCells = [];
                    this.render();
                }, 5000);
            },

            applyHint() {
                if (!this.currentHint || this.currentHint.value === null) {
                    this.showMessage('Get a hint first!', 'info');
                    return;
                }

                this.grid[this.currentHint.row][this.currentHint.col] = this.currentHint.value;
                this.currentHint = null;
                this.highlightedCells = [];
                this.checkComplete();
                this.render();
                this.showMessage('Hint applied!', 'success');
                setTimeout(() => this.hideMessage(), 2000);
            },

            solveAll() {
                this.grid = this.solution.map(row => [...row]);
                this.isRunning = false;
                this.render();
                this.showMessage('Puzzle solved!', 'success');
            },

            applyHintFromSettings() {
                this.closeSettings();
                this.applyHint();
            },

            solveAllFromSettings() {
                this.closeSettings();
                this.solveAll();
            },

            checkComplete() {
                const isFilled = this.grid.every(row => row.every(cell => cell !== 0));
                if (isFilled) {
                    const isCorrect = this.grid.every((row, i) =>
                        row.every((cell, j) => cell === this.solution[i][j])
                    );
                    if (isCorrect) {
                        this.isRunning = false;
                        this.trackGameComplete(this.difficulty, this.timer);

                        const timeStr = this.formatTime(this.timer);
                        const avg = this.getAverageTime(this.difficulty);
                        let message = `üéâ Solved in ${timeStr}!`;
                        if (avg) {
                            const diff = this.timer - avg;
                            const diffStr = this.formatTime(Math.abs(diff));
                            if (diff < 0) {
                                message += ` (${diffStr} faster than avg)`;
                            } else if (diff > 0) {
                                message += ` (${diffStr} slower than avg)`;
                            }
                        }
                        this.showMessage(message, 'success');
                        document.getElementById('newGameBtn').classList.add('show');
                    } else {
                        this.showMessage('Some cells are incorrect!', 'error');
                        setTimeout(() => this.hideMessage(), 3000);
                    }
                }
            },

            showMessage(text, type) {
                const msg = document.getElementById('message');
                msg.textContent = text;
                msg.className = `message ${type}`;
                msg.style.display = 'block';
            },

            hideMessage() {
                document.getElementById('message').style.display = 'none';
            },

            showInstallInstructions() {
                // Check if already installed or dismissed
                if (window.matchMedia('(display-mode: standalone)').matches) {
                    return; // Already installed
                }

                if (localStorage.getItem('installBannerDismissed')) {
                    return; // User dismissed it
                }

                const banner = document.getElementById('installBanner');
                const instructions = document.getElementById('installInstructions');
                
                // Detect platform
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    instructions.innerHTML = 'üçé Safari: Tap <strong>Share</strong> ‚Üí <strong>Add to Home Screen</strong>';
                    banner.style.display = 'block';
                } else if (isAndroid) {
                    instructions.innerHTML = 'ü§ñ Chrome: Tap <strong>‚ãÆ</strong> menu ‚Üí <strong>Add to Home screen</strong>';
                    banner.style.display = 'block';
                } else {
                    // Desktop or other browsers
                    instructions.innerHTML = 'üíª Install this app for quick access!';
                    banner.style.display = 'block';
                }
            },

            dismissInstallBanner() {
                document.getElementById('installBanner').style.display = 'none';
                localStorage.setItem('installBannerDismissed', 'true');
            },

            render() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        const isGiven = this.initialGrid[row][col] !== 0;
                        const isSelected = this.selectedCell && this.selectedCell[0] === row && this.selectedCell[1] === col;
                        const isHighlighted = this.highlightedCells.some(([r, c]) => r === row && c === col);
                        
                        if (isGiven) cell.classList.add('given');
                        if (isSelected) cell.classList.add('selected');
                        if (isHighlighted) cell.classList.add('highlighted');
                        if (!isGiven && this.grid[row][col] !== 0) cell.classList.add('user-input');

                        const key = `${row}-${col}`;
                        const cellNotes = this.notes[key] || [];
                        
                        if (cellNotes.length > 0 && this.grid[row][col] === 0) {
                            const notesDiv = document.createElement('div');
                            notesDiv.className = 'notes';
                            for (let num = 1; num <= 6; num++) {
                                const noteEl = document.createElement('div');
                                noteEl.className = 'note';
                                noteEl.textContent = cellNotes.includes(num) ? num : '';
                                notesDiv.appendChild(noteEl);
                            }
                            cell.appendChild(notesDiv);
                        } else if (this.grid[row][col] !== 0) {
                            cell.textContent = this.grid[row][col];
                        }

                        cell.onclick = () => this.selectCell(row, col);
                        gridEl.appendChild(cell);
                    }
                }
            }
        };

        window.onload = () => {
            app.init();

            // Show install instructions based on platform
            app.showInstallInstructions();

            // Keyboard input support
            document.addEventListener('keydown', (e) => {
                // Escape to close modals
                if (e.key === 'Escape') {
                    app.closeSettings();
                    app.closeStats();
                    return;
                }
                // Don't handle other keys if modal is open
                if (document.getElementById('settingsModal').classList.contains('show') ||
                    document.getElementById('statsModal').classList.contains('show')) {
                    return;
                }
                // Number keys 1-6
                if (e.key >= '1' && e.key <= '6') {
                    app.inputNumber(parseInt(e.key));
                }
                // Backspace or Delete to clear
                else if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    app.clearCell();
                }
                // Arrow keys for navigation
                else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!app.selectedCell) {
                        app.selectCell(0, 0);
                    } else {
                        let [row, col] = app.selectedCell;
                        if (e.key === 'ArrowUp') row = Math.max(0, row - 1);
                        else if (e.key === 'ArrowDown') row = Math.min(5, row + 1);
                        else if (e.key === 'ArrowLeft') col = Math.max(0, col - 1);
                        else if (e.key === 'ArrowRight') col = Math.min(5, col + 1);
                        app.selectCell(row, col);
                    }
                }
                // N key to toggle notes mode
                else if (e.key === 'n' || e.key === 'N') {
                    app.toggleNotes();
                }
                // H key for hint
                else if (e.key === 'h' || e.key === 'H') {
                    app.getHint();
                }
                // Z key for undo (Ctrl/Cmd+Z)
                else if ((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    app.undo();
                }
            });

            // Register service worker for PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('Service Worker registered', reg))
                    .catch(err => console.log('Service Worker registration failed', err));
            }
        };
    </script>
</body>
</html>
