<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a66c2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Mini Sudoku">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%230a66c2'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='280' fill='white' font-family='Arial'>6√ó6</text></svg>">
    <title>Mini Sudoku 6√ó6</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #f3f2ef;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 420px;
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        /* Top bar */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 8px;
        }

        .top-bar h1 {
            font-size: 18px;
            font-weight: 600;
            color: #000;
        }

        .top-bar-center {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: #666;
        }

        .top-bar-center .timer {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .settings-btn:active {
            background: #f5f5f5;
        }

        .menu-btn {
            padding: 6px;
            border: none;
            background: transparent;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        /* Grid */
        .grid-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            min-height: 0;
        }

        .sudoku-grid {
            display: inline-grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0;
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
            background: #444;
            transition: filter 0.3s ease;
        }

        .sudoku-grid.blurred {
            filter: blur(8px);
            pointer-events: none;
        }

        .cell {
            width: 52px;
            height: 52px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 500;
            cursor: pointer;
            position: relative;
            border: 0.5px solid #ccc;
            user-select: none;
            touch-action: manipulation;
        }

        .cell:active {
            background: #f0f0f0;
        }

        .cell.given {
            color: #000;
            background: white;
            font-weight: 600;
            cursor: default;
        }

        .cell.given.selected {
            box-shadow: inset 0 0 0 2px #00000040;
        }

        .cell.user-input {
            color: #666;
            font-weight: 500;
        }

        .cell.selected {
            background: #e8f0fe !important;
            box-shadow: inset 0 0 0 2px #1a73e8;
        }

        .cell.highlighted {
            background: #fff4cc;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { background: #fff4cc; }
            50% { background: #ffe999; }
        }

        .cell.complete-flash {
            animation: complete-flash 0.6s ease-out;
        }

        @keyframes complete-flash {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.given.complete-flash {
            animation: complete-flash-given 0.6s ease-out;
        }

        @keyframes complete-flash-given {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.user-input.complete-flash {
            animation: complete-flash-user 0.6s ease-out;
        }

        @keyframes complete-flash-user {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.conflict {
            background: repeating-linear-gradient(
                45deg,
                #fff,
                #fff 4px,
                #ffcccc 4px,
                #ffcccc 8px
            ) !important;
            color: #c00 !important;
        }

        .cell.conflict.given {
            color: #c00 !important;
        }

        /* 2√ó3 block borders */
        .cell:nth-child(3),
        .cell:nth-child(9),
        .cell:nth-child(15),
        .cell:nth-child(21),
        .cell:nth-child(27),
        .cell:nth-child(33) {
            border-right: 2px solid #444;
        }

        .cell:nth-child(7),
        .cell:nth-child(8),
        .cell:nth-child(9),
        .cell:nth-child(10),
        .cell:nth-child(11),
        .cell:nth-child(12) {
            border-bottom: 2px solid #444;
        }

        .cell:nth-child(19),
        .cell:nth-child(20),
        .cell:nth-child(21),
        .cell:nth-child(22),
        .cell:nth-child(23),
        .cell:nth-child(24) {
            border-bottom: 2px solid #444;
        }

        .notes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
            padding: 3px;
        }

        .note {
            font-size: 11px;
            color: #00000066;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 400;
        }

        /* Action buttons */
        .action-bar {
            display: flex;
            justify-content: center;
            gap: 32px;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #666;
            font-size: 12px;
            font-weight: 500;
        }

        .action-btn:active {
            opacity: 0.7;
        }

        .action-btn.active {
            color: #1a73e8;
        }

        .action-btn .icon {
            font-size: 20px;
        }

        /* Number pad */
        .number-pad {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px 0;
            padding-bottom: 48px;
        }

        .number-btn {
            padding: 16px;
            font-size: 22px;
            font-weight: 500;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            color: #000;
            cursor: pointer;
            transition: all 0.15s;
        }

        .number-btn:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }

        .number-btn.action {
            font-size: 12px;
            color: #666;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .number-btn.action .icon {
            font-size: 18px;
        }

        /* Message */
        .message {
            padding: 10px 16px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.4;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.info {
            background: #e8f4fd;
            color: #0c5460;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .modal-section {
            margin-bottom: 16px;
        }

        .modal-section label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .option-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            background: white;
            color: #333;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .option-btn.active {
            border-color: #1a73e8;
            background: #e8f0fe;
            color: #1a73e8;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .modal-btn.primary {
            background: #1a73e8;
            color: white;
        }

        .modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .stats-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f8f8f8;
            border-radius: 6px;
            font-size: 13px;
        }

        .stat-row .label {
            color: #333;
            font-weight: 500;
        }

        .stat-row .value {
            color: #666;
        }

        .stat-row .count {
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .stats-empty {
            color: #999;
            font-size: 13px;
            text-align: center;
            padding: 12px;
        }

        .stats-chart {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .stats-chart svg {
            width: 100%;
            height: auto;
        }

        .chart-summary {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            padding: 0 4px;
        }

        .chart-summary .stat {
            text-align: center;
        }

        .chart-summary .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .chart-summary .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #999;
        }

        .new-game-btn {
            display: none;
            width: 100%;
            padding: 14px;
            margin-top: 8px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .new-game-btn.show {
            display: block;
        }

        .new-game-btn:active {
            background: #1557b0;
        }

        /* Archive View */
        .archive-view {
            background: white;
            max-width: 420px;
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .archive-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        .archive-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .archive-back-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            font-size: 14px;
            color: #1a73e8;
            cursor: pointer;
            font-weight: 500;
        }

        .archive-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
        }

        .archive-level {
            display: flex;
            align-items: center;
            padding: 16px;
            margin-bottom: 8px;
            background: #f8f8f8;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .archive-level:hover {
            background: #f0f0f0;
        }

        .archive-level:active {
            background: #e8e8e8;
        }

        .level-name {
            flex: 1;
            font-size: 16px;
            font-weight: 500;
        }

        .level-time {
            font-size: 14px;
            color: #666;
            margin-right: 12px;
            font-family: monospace;
        }

        .level-status {
            font-size: 16px;
            color: #10b981;
            width: 20px;
            text-align: center;
        }

        .archive-empty {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 360px) {
            .cell {
                width: 46px;
                height: 46px;
                font-size: 22px;
            }
        }

        @media (min-width: 400px) {
            .cell {
                width: 56px;
                height: 56px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1>Mini Sudoku</h1>
            <div class="top-bar-center">
                <div class="timer">
                    <span>‚è±</span>
                    <span id="timer">0:00</span>
                </div>
            </div>
            <div class="top-bar-right">
                <button class="menu-btn" onclick="app.openArchive()" title="Levels">üìö</button>
                <button class="menu-btn" onclick="app.openStats()" title="Stats">üìä</button>
                <button class="settings-btn" onclick="app.openSettings()">
                    Settings <span>‚ñæ</span>
                </button>
                <button class="menu-btn" onclick="app.handleNewGame()">‚ü≥</button>
            </div>
        </div>

        <!-- Install Banner (hidden by default) -->
        <div id="installBanner" style="display: none; background: #e8f4fd; border-radius: 8px; padding: 10px; margin-bottom: 8px; text-align: center;">
            <div style="font-size: 12px; color: #1a73e8;" id="installInstructions"></div>
            <button style="margin-top: 6px; padding: 4px 12px; border: none; background: #1a73e8; color: white; border-radius: 4px; font-size: 12px; cursor: pointer;" onclick="app.dismissInstallBanner()">Got it</button>
        </div>

        <!-- Message area -->
        <div id="message" style="display: none;"></div>
        <button class="new-game-btn" id="newGameBtn" onclick="app.newPuzzle()">New Game</button>

        <!-- Grid -->
        <div class="grid-wrapper">
            <div class="sudoku-grid" id="grid"></div>
        </div>

        <!-- Action Bar -->
        <div class="action-bar">
            <button class="action-btn" onclick="app.getHint()">
                <span class="icon">üí°</span>
                <span>Hint</span>
            </button>
            <button class="action-btn" id="notesBtn" onclick="app.toggleNotes()">
                <span class="icon">‚úèÔ∏è</span>
                <span>Notes <span id="notesStatus">OFF</span></span>
            </button>
        </div>

        <!-- Number Pad -->
        <div class="number-pad">
            <button class="number-btn" onclick="app.inputNumber(1)">1</button>
            <button class="number-btn" onclick="app.inputNumber(2)">2</button>
            <button class="number-btn" onclick="app.inputNumber(3)">3</button>
            <button class="number-btn action" onclick="app.clearCell()">
                <span class="icon">‚úï</span>
                <span>Erase</span>
            </button>
            <button class="number-btn" onclick="app.inputNumber(4)">4</button>
            <button class="number-btn" onclick="app.inputNumber(5)">5</button>
            <button class="number-btn" onclick="app.inputNumber(6)">6</button>
            <button class="number-btn action" onclick="app.undo()">
                <span class="icon">‚Ü∫</span>
                <span>Undo</span>
            </button>
        </div>
    </div>

    <!-- Archive View (full screen) -->
    <div class="archive-view" id="archiveView" style="display: none;">
        <div class="archive-header">
            <button class="archive-back-btn" onclick="app.closeArchive()">‚Üê Back</button>
            <h2>Levels</h2>
            <div style="width: 60px;"></div>
        </div>
        <div class="archive-list" id="archiveLevelList">
            <!-- Levels rendered dynamically -->
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal" onclick="app.closeStatsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 360px;">
            <h2>Stats</h2>

            <div class="modal-section">
                <label>Filter by Difficulty</label>
                <div class="option-group" id="statsFilterOptions">
                    <button class="option-btn active" data-value="all" onclick="app.filterStats('all')">All</button>
                    <button class="option-btn" data-value="easy" onclick="app.filterStats('easy')">Easy</button>
                    <button class="option-btn" data-value="medium" onclick="app.filterStats('medium')">Medium</button>
                    <button class="option-btn" data-value="hard" onclick="app.filterStats('hard')">Hard</button>
                    <button class="option-btn" data-value="expert" onclick="app.filterStats('expert')">Expert</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Solve Time Progress</label>
                <div id="statsChart" class="stats-chart">
                    <svg id="chartSvg" viewBox="0 0 320 160"></svg>
                </div>
                <div id="chartSummary" class="chart-summary"></div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.resetStats()">Reset</button>
                <button class="modal-btn primary" onclick="app.closeStats()">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal" onclick="app.closeSettingsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <h2>Settings</h2>

            <div class="modal-section">
                <label>Difficulty</label>
                <div class="option-group" id="difficultyOptions">
                    <button class="option-btn" data-value="easy">Easy</button>
                    <button class="option-btn active" data-value="medium">Medium</button>
                    <button class="option-btn" data-value="hard">Hard</button>
                    <button class="option-btn" data-value="expert">Expert</button>
                    <button class="option-btn" data-value="ultra">Ultra</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Hint Detail</label>
                <div class="option-group" id="hintOptions">
                    <button class="option-btn" data-value="strategy">Strategy Only</button>
                    <button class="option-btn" data-value="location">+ Location</button>
                    <button class="option-btn active" data-value="full">Full Hint</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Timer</label>
                <div class="option-group">
                    <button class="option-btn" id="timerToggleBtn" onclick="app.toggleTimer()">
                        <span id="timerBtnText">Pause</span>
                    </button>
                </div>
            </div>

            <div class="modal-section">
                <label>Actions</label>
                <div class="option-group">
                    <button class="option-btn" onclick="app.applyHintFromSettings()">Apply Hint</button>
                    <button class="option-btn" onclick="app.solveAllFromSettings()">Solve All</button>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.closeSettings()">Close</button>
                <button class="modal-btn primary" onclick="app.newPuzzleFromSettings()">New Puzzle</button>
            </div>
        </div>
    </div>

    <!-- Solve Stats Modal -->
    <div class="modal-overlay" id="solveStatsModal" onclick="app.closeSolveStatsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 360px;">
            <h2>Puzzle Complete</h2>
            <div class="modal-section">
                <div id="solveStatsSummary" class="chart-summary"></div>
            </div>
            <div class="modal-section">
                <label>Speed Over Time</label>
                <div class="stats-chart">
                    <svg id="solveChartSvg" viewBox="0 0 320 160"></svg>
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn primary" onclick="app.closeSolveStats()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const app = {
            grid: [],
            solution: [],
            initialGrid: [],
            selectedCell: null,
            mode: 'normal',
            notes: {},
            timer: 0,
            timerInterval: null,
            isRunning: true,
            hintLevel: 'full',
            currentHint: null,
            highlightedCells: [],
            history: [], // For undo functionality
            solveAttempts: [],   // [{ t: seconds, correct: bool }, ...]
            difficulty: 'medium',

            // Stats tracking
            stats: {
                gamesByDifficulty: {},  // { 'easy': [{time: 120, date: ...}, ...], ... }
            },
            statsFilter: 'all',

            // Archive mode
            currentMode: 'random',      // 'random' | 'archive'
            currentLevelId: null,
            archiveProgress: {},        // { "1": { bestTime: 145, completedAt: "..." }, ... }

            // Hardcoded archive levels (add your puzzles here)
            LEVELS: [
                { id: 1, grid: "123450050030004060000310500020000000", solution: "123456456132314265265314541623632541" },
                { id: 2, grid: "100005020030003500001400040050300006", solution: "134625526134463512251463642351315246" },
                { id: 3, grid: "123400500000600000000001000003004265", solution: "123456546312631524452631265143314265" },
                { id: 4, grid: "600001500003040020030050002400001600", solution: "623541514263145326236154362415451632" },
                { id: 5, grid: "003200040010050000060040001300000000", solution: "513264246513154632362145421356635421" },
                { id: 6, grid: "100000005230204005306004401003000000", solution: "132546645231214365356124421653563412" },
                { id: 7, grid: "000000012340040020050030036450000000", solution: "364215512346643521251634136452425163" },
                { id: 8, grid: "200000100400000502000003056000000056", solution: "245631163425631542524163356214412356" },
                { id: 9, grid: "000000123000045600000000006510000263", solution: "564132123456345621612345236514451263" },
                { id: 10, grid: "010000234000050000000306000040000205", solution: "615432234561356124142356521643463215" },
                { id: 11, grid: "000000012300004230000560000010500000", solution: "365142412356654231123564236415541623" },
                { id: 12, grid: "000000012300004230000560000010500000", solution: "365142412356654231123564236415541623" },
                { id: 13, grid: "000000010020020016030045040050002100", solution: "253461614523425316136245341652562134" },
                { id: 14, grid: "001200000340400056610003023000004500", solution: "341265256341432156615423523614164532" },
                { id: 15, grid: "000000230014450023000000100006023450", solution: "514362236514451623362145145236623451" },
                { id: 16, grid: "065400000020006500000010054200000000", solution: "265431431625316542542316154263623154" },
                { id: 17, grid: "001000020300400020050006003060000500", solution: "341652625341436125152436513264264513" },
                { id: 18, grid: "000000405030360510000000123450000000", solution: "236145415632362514541263123456654321" },
                { id: 19, grid: "010000203000040500006020000102000060", solution: "614253253614142536536421365142421365" },
                { id: 20, grid: "000000004500010060023450030010000000", solution: "352146164523415362623451536214241635" },
                { id: 21, grid: "001200003400120043340025004300002500", solution: "451236263451125643346125514362632514" },
                { id: 22, grid: "012000000230034000000450026000000120", solution: "312564645231534612261453126345453126" },
                { id: 23, grid: "005100010040000300006000034560000000", solution: "645123213645421356356214134562562431" },
                { id: 24, grid: "010000020050300060400100000300000000", solution: "514623623451351264462135245316136542" },
                { id: 25, grid: "000006000050000403003060020504104030", solution: "531246462351615423243165326514154632" },
                { id: 26, grid: "000500002000500030010002000400003000", solution: "431526652341526134314652265413143265" },
                { id: 27, grid: "450000000010000200003000040000000036", solution: "451362632514164253523641346125215436" },
                { id: 28, grid: "102030030102405060020501501020040605", solution: "152436634152415263326541561324243615" },
                { id: 29, grid: "123400000000034560000000002345000000", solution: "123456456123234561561234612345345612" },
                { id: 30, grid: "605000004000060005200040000300000201", solution: "635412124536463125251643512364346251" },
                { id: 31, grid: "000123000004000010030000200000345000", solution: "564123123654452316631542216435345261" },
                { id: 32, grid: "001200000030000304003005020000400000", solution: "351246264531512364643125126453435612" },
                { id: 33, grid: "600000300201000504000010030050040000", solution: "612345354261163524425613231456546132" },
                { id: 34, grid: "010000200050000400003000020006000041", solution: "514362236154652413143625421536365241" },
                { id: 35, grid: "120045340061560023001600002500003400", solution: "126345345261564123231654412536653412" },
                { id: 36, grid: "000000123000345000000345000214000000", solution: "654132123456345621261345536214412563" },
                { id: 37, grid: "100000200060340050050042010003000004", solution: "164235235461342156651342416523523614" },
                { id: 38, grid: "000003034502000001600000501230400000", solution: "256413134562345621612345561234423156" },
                { id: 39, grid: "034500200060100030020400002000001000", solution: "634521215364146235523416462153351642" },
                { id: 40, grid: "003400020050100006600003040020005100", solution: "513462426351132546654213341625265134" },
                { id: 41, grid: "000000002340010005030006050004001650", solution: "143562562341614235235416356124421653" },
                { id: 42, grid: "045600600050501040402300300004024560", solution: "245631613452531246462315356124124563" },
                { id: 43, grid: "000000060502050401020305001230000100", solution: "215643463512356421124365541236632154" },
                { id: 44, grid: "000000000056000140005600034000120000", solution: "653412241356362145415623534261126534" },
                { id: 45, grid: "012300000002100003300004500000006540", solution: "412365653412124653365124541236236541" },
                { id: 46, grid: "000000012340020050030000046020000000", solution: "463215512346624153135462346521251634" },
                { id: 47, grid: "000050000043001200003400230000040000", solution: "314652652143461235523461236514145326" },
                { id: 48, grid: "000001010200002030030400004005500060", solution: "253641416253142536635412364125521364" },
                { id: 49, grid: "230045100006002500004200400001560032", solution: "236145145326312564654213423651561432" },
                { id: 50, grid: "000060000501000403023005100030034100", solution: "541362362541615423423615156234234156" },
                { id: 51, grid: "000120230000000034450000000056045000", solution: "564123231645126534453261312456645312" },
                { id: 52, grid: "006000001000400001200004000300000600", solution: "546123321456465231213564654312132645" },
                { id: 53, grid: "000000100006230045000000003400050030", solution: "362514145326236145514263623451451632" },
                { id: 54, grid: "021340040000003000000500000030032410", solution: "521346346251253164164523415632632415" },
                { id: 55, grid: "100000000002000030000004004050020603", solution: "132465456312245136613524364251521643" },
                { id: 56, grid: "000400003520024036130240065310002000", solution: "251463643521524136136245465312312654" },
                { id: 57, grid: "023056450001600000000004200045340610", solution: "123456456231614523532164261345345612" },
                { id: 58, grid: "000000034500120650000000002460065013", solution: "251346634521123654546132312465465213" },
                { id: 59, grid: "003400020050100006004300050020000000", solution: "513462426153135246264315351624642531" },
                { id: 60, grid: "100000020030003600005400040050000006", solution: "134562526134413625265413642351351246" },
                { id: 61, grid: "001200000030030040020050010000005400", solution: "351264642531536142124356413625265413" },
                { id: 62, grid: "060010400003000600005000500002030040", solution: "263415451263324651615324546132132546" },
                { id: 63, grid: "000000006500065430032150210045650021", solution: "541263326514165432432156213645654321" },
                { id: 64, grid: "234000105000456000000456000601000532", solution: "234165165324456213312456523641641532" },
                { id: 65, grid: "100064300000003400006500000005240003", solution: "152364364152513426426531631245245613" },
                { id: 66, grid: "300004020050001600002100040060500003", solution: "365214124356451632632145243561516423" },
                { id: 67, grid: "000100001002030020050040500200004000", solution: "245136361452436521152643513264624315" },
                { id: 68, grid: "013000005310000050040000024600000240", solution: "413526265314631452542163124635356241" },
                { id: 69, grid: "003040000005500200002006300000060300", solution: "653142214635546213132456321564465321" },
                { id: 70, grid: "010000234000561040020165000432000010", solution: "615324234651561243423165156432342516" },
                { id: 71, grid: "123400000030610003002004300205040301", solution: "123456456132614523532614361245245361" },
                { id: 72, grid: "012000003400000000000120120034054000", solution: "412356563412231645645123126534354261" },
                { id: 73, grid: "003400020050010060004100000000001200", solution: "153426426351312564564132245613631245" },
                { id: 74, grid: "000104000200000023520000006000401000", solution: "362154145236614523523641236415451362" },
                { id: 75, grid: "012300000000600003300004000000005420", solution: "412365563142654213321654246531135426" },
                { id: 76, grid: "000060120000003000000200000043050000", solution: "435162126354263415541236612543354621" },
                { id: 77, grid: "010040234056000010060000650324040060", solution: "516243234156423615165432651324342561" },
                { id: 78, grid: "040100123450060200234560050300000000", solution: "645123123456561234234561456312312645" },
                { id: 79, grid: "000000040500301060200010100030000000", solution: "512643643521351264264315125436436152" },
                { id: 80, grid: "000000052610024000010300040020000001", solution: "631254452613324165516342143526265431" },
                { id: 81, grid: "005100040030200006030010020050010060", solution: "365124142635251346436512623451514263" },
                { id: 82, grid: "000000032100040020050060001530000000", solution: "614253532146146325253461461532325614" },
                { id: 83, grid: "010400020500030600002030003040004050", solution: "315462426513531624642135153246264351" },
                { id: 84, grid: "100034230560040000000002056023320040", solution: "165234234561542316613452456123321645" },
                { id: 85, grid: "350006410050000400003000020031100064", solution: "352146416352561423243615624531135264" },
                { id: 86, grid: "000561005002040003300050200600164000", solution: "432561615342546123321456253614164235" },
                { id: 87, grid: "000320004001005000000600500100032000", solution: "651324324561465213213645546132132456" },
                { id: 88, grid: "000000102030000004300000060402000000", solution: "635241142635216354354126563412421563" },
                { id: 89, grid: "000000040003001020030100200050000000", solution: "326514145263451326632145263451514632" },
                { id: 90, grid: "000000400050060400003000020600100020", solution: "615243432156561432243561324615156324" },
                { id: 91, grid: "012345000012000034450000261000345260", solution: "612345534612126534453126261453345261" },
                { id: 92, grid: "023400010023200004300005450010006540", solution: "623451514623265134341265452316136542" },
                { id: 93, grid: "000023002001034000000530200100650000", solution: "415623362451534216126534243165651342" },
                { id: 94, grid: "020000130420040001050030312005000310", solution: "426153135426243561651234312645564312" },
                { id: 95, grid: "300000020010100200006004040050000006", solution: "361542425613134265256134642351513426" },
                { id: 96, grid: "100000200006030005040030000040000000", solution: "163254254316631425542631316542425163" },
                { id: 97, grid: "001300050000300002100006000060006400", solution: "621354453621365142142536514263236415" },
                { id: 98, grid: "020000450123060004010065135040000030", solution: "321456456123563214214365135642642531" },
                { id: 99, grid: "120000340610000230034000052061000025", solution: "126543345612561234234156452361613425" },
                { id: 100, grid: "000012005634301256206300400000000000", solution: "634512125634341256256341463125512463" },
                { id: 188, grid: "001000000103000020030000204000000500", solution: "361254425163146325532416254631613542" },
                { id: 189, grid: "002300406501500002003100300004014250", solution: "152346436521561432243165325614614253" },



            ],

            init() {
                this.loadStats();
                this.loadArchiveProgress();
                this.initSettingsListeners();
                this.newPuzzle();
            },

            loadStats() {
                try {
                    const saved = localStorage.getItem('sudokuStats');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        this.stats = {
                            gamesByDifficulty: parsed.gamesByDifficulty || {}
                        };
                    }
                } catch (e) {
                    console.error('Failed to load stats:', e);
                    this.stats = { gamesByDifficulty: {} };
                }
            },

            saveStats() {
                try {
                    localStorage.setItem('sudokuStats', JSON.stringify(this.stats));
                } catch (e) {
                    console.error('Failed to save stats:', e);
                }
            },

            // Archive functions
            loadArchiveProgress() {
                try {
                    const saved = localStorage.getItem('archiveProgress');
                    if (saved) {
                        this.archiveProgress = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Failed to load archive progress:', e);
                    this.archiveProgress = {};
                }
            },

            saveArchiveProgress() {
                try {
                    localStorage.setItem('archiveProgress', JSON.stringify(this.archiveProgress));
                } catch (e) {
                    console.error('Failed to save archive progress:', e);
                }
            },

            encodeGrid(grid) {
                return grid.map(row => row.join('')).join('');
            },

            decodeGrid(str) {
                const grid = [];
                for (let i = 0; i < 6; i++) {
                    const row = [];
                    for (let j = 0; j < 6; j++) {
                        row.push(parseInt(str[i * 6 + j]) || 0);
                    }
                    grid.push(row);
                }
                return grid;
            },

            openArchive() {
                document.querySelector('.container').style.display = 'none';
                document.getElementById('archiveView').style.display = 'flex';
                this.renderArchiveList();
            },

            closeArchive() {
                document.getElementById('archiveView').style.display = 'none';
                document.querySelector('.container').style.display = 'flex';
            },

            renderArchiveList() {
                const list = document.getElementById('archiveLevelList');
                if (this.LEVELS.length === 0) {
                    list.innerHTML = '<div class="archive-empty">No levels yet. Use creator.html to add puzzles.</div>';
                    return;
                }

                list.innerHTML = this.LEVELS.map(level => {
                    const progress = this.archiveProgress[level.id];
                    const completed = progress && progress.bestTime;
                    const timeStr = completed ? this.formatTime(progress.bestTime) : '--:--';
                    return `
                        <div class="archive-level" onclick="app.playLevel(${level.id})">
                            <span class="level-name">Level ${level.id}</span>
                            <span class="level-time">${timeStr}</span>
                            <span class="level-status">${completed ? '‚úì' : ''}</span>
                        </div>
                    `;
                }).join('');
            },

            playLevel(id) {
                const level = this.LEVELS.find(l => l.id === id);
                if (!level) return;

                this.currentMode = 'archive';
                this.currentLevelId = id;
                this.grid = this.decodeGrid(level.grid);
                this.initialGrid = this.decodeGrid(level.grid);
                this.solution = this.decodeGrid(level.solution);
                this.selectedCell = null;
                this.notes = {};
                this.history = [];
                this.solveAttempts = [];
                this.timer = 0;
                this.isRunning = true;
                this.currentHint = null;
                this.highlightedCells = [];

                this.closeArchive();
                this.startTimer();
                this.render();
                this.hideMessage();
                document.getElementById('newGameBtn').classList.remove('show');

                // Update header to show level
                document.querySelector('.top-bar h1').textContent = `Level ${id}`;
            },

            backToArchive() {
                this.currentMode = 'random';
                this.currentLevelId = null;
                document.querySelector('.top-bar h1').textContent = 'Mini Sudoku';
                document.getElementById('newGameBtn').classList.remove('show');
                this.hideMessage();
                this.openArchive();
            },

            trackGameComplete(difficulty, time) {
                if (!this.stats.gamesByDifficulty[difficulty]) {
                    this.stats.gamesByDifficulty[difficulty] = [];
                }
                this.stats.gamesByDifficulty[difficulty].push({
                    time,
                    date: new Date().toISOString()
                });
                // Keep only last 50 games per difficulty
                if (this.stats.gamesByDifficulty[difficulty].length > 50) {
                    this.stats.gamesByDifficulty[difficulty].shift();
                }
                this.saveStats();
            },

            getAverageTime(difficulty) {
                const games = this.stats.gamesByDifficulty[difficulty];
                if (!games || games.length === 0) return null;
                const total = games.reduce((sum, g) => sum + g.time, 0);
                return Math.round(total / games.length);
            },

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            openStats() {
                this.statsFilter = 'all';
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
                document.getElementById('statsModal').classList.add('show');
            },

            closeStats() {
                document.getElementById('statsModal').classList.remove('show');
            },

            closeStatsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeStats();
                }
            },

            openSolveStats() {
                this.renderSolveStatsChart();
                document.getElementById('solveStatsModal').classList.add('show');
            },

            closeSolveStats() {
                document.getElementById('solveStatsModal').classList.remove('show');
            },

            closeSolveStatsOnOverlay(event) {
                if (event.target === event.currentTarget) this.closeSolveStats();
            },

            renderSolveStatsChart() {
                const attempts = this.solveAttempts;
                const svg = document.getElementById('solveChartSvg');
                const summary = document.getElementById('solveStatsSummary');

                const totalInputs = attempts.length;
                const correctInputs = attempts.filter(a => a.correct).length;
                const accuracy = totalInputs > 0 ? Math.round((correctInputs / totalInputs) * 100) : 0;
                const cspm = this.timer > 0 ? Math.round((correctInputs / this.timer) * 60 * 10) / 10 : 0;

                summary.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(this.timer)}</div>
                        <div class="stat-label">Solve Time</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${accuracy}%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${cspm}</div>
                        <div class="stat-label">CSPM</div>
                    </div>`;

                if (attempts.length === 0) {
                    svg.innerHTML = '<text x="160" y="85" text-anchor="middle" fill="#999" font-size="13">No inputs recorded</text>';
                    return;
                }

                // Compute rolling CSPM at each attempt
                const points = [];
                let correctSoFar = 0;
                attempts.forEach(a => {
                    if (a.correct) correctSoFar++;
                    const rollingCspm = a.t > 0 ? (correctSoFar / a.t) * 60 : (a.correct ? 60 : 0);
                    points.push({ t: a.t, cspm: rollingCspm, correct: a.correct });
                });

                // Chart dimensions
                const width = 320, height = 160;
                const pad = { top: 20, right: 20, bottom: 30, left: 45 };
                const cw = width - pad.left - pad.right;
                const ch = height - pad.top - pad.bottom;

                const maxT = Math.max(...points.map(p => p.t), 1);
                const maxC = Math.max(...points.map(p => p.cspm), 1);
                const xScale = t => pad.left + (t / maxT) * cw;
                const yScale = c => pad.top + ch - (c / (maxC * 1.1)) * ch;

                let svgContent = '';

                // Grid lines + Y labels
                for (let i = 0; i <= 4; i++) {
                    const val = (maxC * 1.1) * (i / 4);
                    const y = yScale(val);
                    svgContent += `<line x1="${pad.left}" y1="${y}" x2="${width - pad.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>`;
                    svgContent += `<text x="${pad.left - 5}" y="${y + 4}" text-anchor="end" fill="#999" font-size="10">${Math.round(val)}</text>`;
                }

                // X-axis
                svgContent += `<line x1="${pad.left}" y1="${height - pad.bottom}" x2="${width - pad.right}" y2="${height - pad.bottom}" stroke="#ccc" stroke-width="1"/>`;
                svgContent += `<text x="${width / 2}" y="${height - 8}" text-anchor="middle" fill="#999" font-size="10">Time (seconds)</text>`;
                svgContent += `<text x="${pad.left - 38}" y="${pad.top + ch / 2}" text-anchor="middle" fill="#999" font-size="10" transform="rotate(-90,${pad.left - 38},${pad.top + ch / 2})">CSPM</text>`;

                // Line path
                if (points.length > 1) {
                    let d = `M ${xScale(points[0].t)} ${yScale(points[0].cspm)}`;
                    for (let i = 1; i < points.length; i++) {
                        d += ` L ${xScale(points[i].t)} ${yScale(points[i].cspm)}`;
                    }
                    svgContent += `<path d="${d}" fill="none" stroke="#1a73e8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                }

                // Dots: green = correct, red = incorrect
                points.forEach(p => {
                    const color = p.correct ? '#10b981' : '#ef4444';
                    svgContent += `<circle cx="${xScale(p.t)}" cy="${yScale(p.cspm)}" r="4" fill="${color}" stroke="white" stroke-width="1.5"/>`;
                });

                svg.innerHTML = svgContent;
            },

            resetStats() {
                if (confirm('Reset all stats? This cannot be undone.')) {
                    this.stats = { gamesByDifficulty: {} };
                    this.saveStats();
                    this.updateStatsDisplay();
                }
            },

            filterStats(difficulty) {
                this.statsFilter = difficulty;
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
            },

            updateStatsFilterUI() {
                document.querySelectorAll('#statsFilterOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.statsFilter);
                });
            },

            getFilteredGames() {
                const difficulties = this.statsFilter === 'all'
                    ? ['easy', 'medium', 'hard', 'expert', 'ultra']
                    : [this.statsFilter];

                let games = [];
                difficulties.forEach(diff => {
                    const diffGames = this.stats.gamesByDifficulty[diff] || [];
                    diffGames.forEach((g, i) => {
                        games.push({ ...g, difficulty: diff, index: i });
                    });
                });

                // Sort by date
                games.sort((a, b) => new Date(a.date) - new Date(b.date));
                return games;
            },

            updateStatsDisplay() {
                const games = this.getFilteredGames();
                const svg = document.getElementById('chartSvg');
                const summary = document.getElementById('chartSummary');

                if (games.length === 0) {
                    svg.innerHTML = '<text x="160" y="85" text-anchor="middle" fill="#999" font-size="13">No games completed yet</text>';
                    summary.innerHTML = '';
                    return;
                }

                // Chart dimensions
                const width = 320;
                const height = 160;
                const padding = { top: 20, right: 20, bottom: 30, left: 45 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                // Calculate scales
                const times = games.map(g => g.time);
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                const timeRange = maxTime - minTime || 60;
                const yMin = Math.max(0, minTime - timeRange * 0.1);
                const yMax = maxTime + timeRange * 0.1;

                const xScale = (i) => padding.left + (i / (games.length - 1 || 1)) * chartWidth;
                const yScale = (t) => padding.top + chartHeight - ((t - yMin) / (yMax - yMin)) * chartHeight;

                // Build SVG
                let svgContent = '';

                // Y-axis labels
                const yTicks = 4;
                for (let i = 0; i <= yTicks; i++) {
                    const val = yMin + (yMax - yMin) * (i / yTicks);
                    const y = yScale(val);
                    svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>`;
                    svgContent += `<text x="${padding.left - 5}" y="${y + 4}" text-anchor="end" fill="#999" font-size="10">${this.formatTime(Math.round(val))}</text>`;
                }

                // X-axis
                svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="#ccc" stroke-width="1"/>`;
                svgContent += `<text x="${width / 2}" y="${height - 8}" text-anchor="middle" fill="#999" font-size="10">Games (${games.length})</text>`;

                // Line path
                if (games.length > 1) {
                    let pathD = `M ${xScale(0)} ${yScale(games[0].time)}`;
                    for (let i = 1; i < games.length; i++) {
                        pathD += ` L ${xScale(i)} ${yScale(games[i].time)}`;
                    }
                    svgContent += `<path d="${pathD}" fill="none" stroke="#1a73e8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                }

                // Points
                const diffColors = { easy: '#10b981', medium: '#f59e0b', hard: '#ef4444', expert: '#8b5cf6', ultra: '#ec4899' };
                games.forEach((g, i) => {
                    const color = diffColors[g.difficulty] || '#1a73e8';
                    svgContent += `<circle cx="${xScale(i)}" cy="${yScale(g.time)}" r="4" fill="${color}" stroke="white" stroke-width="1.5"/>`;
                });

                svg.innerHTML = svgContent;

                // Summary stats
                const avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                const bestTime = Math.min(...times);
                const latestTime = times[times.length - 1];

                summary.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(bestTime)}</div>
                        <div class="stat-label">Best</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(avgTime)}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(latestTime)}</div>
                        <div class="stat-label">Latest</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${games.length}</div>
                        <div class="stat-label">Games</div>
                    </div>
                `;
            },

            isValid(grid, row, col, num) {
                for (let x = 0; x < 6; x++) {
                    if (grid[row][x] === num) return false;
                    if (grid[x][col] === num) return false;
                }
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[boxRow + i][boxCol + j] === num) return false;
                    }
                }
                return true;
            },

            solve(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (this.solve(grid)) return true;
                                    grid[row][col] = 0;
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            },

            // Count solutions (stops at 2 since we only need to know if unique)
            countSolutions(grid, count = { value: 0 }) {
                if (count.value >= 2) return count.value; // Early exit if multiple found

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    this.countSolutions(grid, count);
                                    grid[row][col] = 0;
                                    if (count.value >= 2) return count.value;
                                }
                            }
                            return count.value;
                        }
                    }
                }
                count.value++;
                return count.value;
            },

            hasUniqueSolution(grid) {
                const gridCopy = grid.map(row => [...row]);
                return this.countSolutions(gridCopy) === 1;
            },

            generatePuzzle(difficulty = 'medium') {
                const grid = Array(6).fill(null).map(() => Array(6).fill(0));

                // Fill the first row with random numbers
                const firstRow = [1, 2, 3, 4, 5, 6].sort(() => Math.random() - 0.5);
                for (let col = 0; col < 6; col++) {
                    grid[0][col] = firstRow[col];
                }

                // Solve the rest
                this.solve(grid);
                const solution = grid.map(row => [...row]);

                const cellsToRemove = {
                    easy: 12,      // More clues = easier
                    medium: 18,    // Moderate clues
                    hard: 22,      // Fewer clues = harder
                    expert: 24,    // Very few clues
                    ultra: 27      // Extreme - requires X-Wing, Y-Wing, BUG
                }[difficulty] || 18;

                // Collect all cell positions and shuffle them
                const positions = [];
                for (let r = 0; r < 6; r++) {
                    for (let c = 0; c < 6; c++) {
                        positions.push([r, c]);
                    }
                }
                // Shuffle positions randomly
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                let removed = 0;

                // Try to remove cells while maintaining unique solution
                for (const [row, col] of positions) {
                    if (removed >= cellsToRemove) break;

                    const backup = grid[row][col];
                    grid[row][col] = 0;

                    // Check if puzzle still has unique solution
                    if (this.hasUniqueSolution(grid)) {
                        removed++;
                    } else {
                        // Restore the cell - removing it creates multiple solutions
                        grid[row][col] = backup;
                    }
                }

                console.log(`Generated ${difficulty} puzzle: removed ${removed}/${cellsToRemove} cells (unique solution guaranteed)`);
                return { puzzle: grid, solution };
            },

            getCandidates(grid, row, col) {
                if (grid[row][col] !== 0) return [];
                const candidates = [];
                for (let num = 1; num <= 6; num++) {
                    if (this.isValid(grid, row, col, num)) {
                        candidates.push(num);
                    }
                }
                return candidates;
            },

            findNakedSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            if (candidates.length === 1) {
                                return {
                                    type: 'Naked Single',
                                    row, col,
                                    value: candidates[0],
                                    explanation: `Cell (${row + 1}, ${col + 1}) can only be ${candidates[0]}. All other numbers are eliminated by existing numbers in its row, column, and box.`,
                                    cells: [[row, col]]
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findHiddenSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(col);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Row)',
                                row, col: positions[0],
                                value: num,
                                explanation: `In row ${row + 1}, the number ${num} can only go in column ${positions[0] + 1}.`,
                                cells: [[row, positions[0]]]
                            };
                        }
                    }
                }

                for (let col = 0; col < 6; col++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(row);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Column)',
                                row: positions[0], col,
                                value: num,
                                explanation: `In column ${col + 1}, the number ${num} can only go in row ${positions[0] + 1}.`,
                                cells: [[positions[0], col]]
                            };
                        }
                    }
                }

                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 3) * 2;
                    const boxCol = (boxIdx % 3) * 3;
                    
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Box)',
                                row: positions[0][0], col: positions[0][1],
                                value: num,
                                explanation: `In box (${Math.floor(boxIdx / 3) + 1}, ${(boxIdx % 3) + 1}), the number ${num} can only go in one position.`,
                                cells: positions
                            };
                        }
                    }
                }
                return null;
            },

            getSmartHint(grid) {
                // Basic techniques (all difficulties)
                let hint = this.findNakedSingle(grid);
                if (hint) return hint;

                hint = this.findHiddenSingle(grid);
                if (hint) return hint;

                // Intermediate techniques (medium+)
                if (this.difficulty !== 'easy') {
                    hint = this.findNakedPair(grid);
                    if (hint) return hint;

                    hint = this.findPointingPair(grid);
                    if (hint) return hint;

                    hint = this.findBoxLineReduction(grid);
                    if (hint) return hint;
                }

                // Advanced techniques (hard+)
                if (this.difficulty === 'hard' || this.difficulty === 'expert' || this.difficulty === 'ultra') {
                    hint = this.findXWing(grid);
                    if (hint) return hint;
                }

                // Expert techniques
                if (this.difficulty === 'expert' || this.difficulty === 'ultra') {
                    hint = this.findYWing(grid);
                    if (hint) return hint;
                }

                // Ultra expert techniques
                if (this.difficulty === 'ultra') {
                    hint = this.findBUG(grid);
                    if (hint) return hint;

                    hint = this.findSwordfish(grid);
                    if (hint) return hint;
                }

                // Fallback
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            const difficultyHints = {
                                'expert': ' Try X-Wing or Y-Wing patterns.',
                                'ultra': ' Try BUG, Swordfish, or advanced chains.'
                            };
                            return {
                                type: 'General Hint',
                                row, col,
                                value: null,
                                explanation: `Cell (${row + 1}, ${col + 1}) has ${candidates.length} candidates: ${candidates.join(', ')}.${difficultyHints[this.difficulty] || ''}`,
                                cells: [[row, col]]
                            };
                        }
                    }
                }
                return null;
            },

            findNakedPair(grid) {
                const allCandidates = {};
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            allCandidates[`${row}-${col}`] = this.getCandidates(grid, row, col);
                        }
                    }
                }
                
                // Check rows
                for (let row = 0; row < 6; row++) {
                    const cellsInRow = [];
                    for (let col = 0; col < 6; col++) {
                        const key = `${row}-${col}`;
                        if (allCandidates[key] && allCandidates[key].length === 2) {
                            cellsInRow.push({ col, candidates: allCandidates[key] });
                        }
                    }
                    
                    for (let i = 0; i < cellsInRow.length; i++) {
                        for (let j = i + 1; j < cellsInRow.length; j++) {
                            const c1 = cellsInRow[i].candidates;
                            const c2 = cellsInRow[j].candidates;
                            if (c1[0] === c2[0] && c1[1] === c2[1]) {
                                return {
                                    type: 'Naked Pair',
                                    explanation: `Row ${row + 1} has a naked pair [${c1[0]}, ${c1[1]}] in columns ${cellsInRow[i].col + 1} and ${cellsInRow[j].col + 1}. These numbers can be eliminated from other cells in this row.`,
                                    cells: [[row, cellsInRow[i].col], [row, cellsInRow[j].col]],
                                    values: c1
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findPointingPair(grid) {
                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 2) * 2;
                    const boxCol = (boxIdx % 2) * 3;
                    
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }
                        
                        if (positions.length >= 2 && positions.length <= 3) {
                            const sameRow = positions.every(([r]) => r === positions[0][0]);
                            if (sameRow) {
                                return {
                                    type: 'Pointing Pair',
                                    explanation: `In box at (${boxRow + 1}, ${boxCol + 1}), number ${num} only appears in row ${positions[0][0] + 1}. Eliminates ${num} from other cells in that row.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                            
                            const sameCol = positions.every(([, c]) => c === positions[0][1]);
                            if (sameCol) {
                                return {
                                    type: 'Pointing Pair',
                                    explanation: `In box at (${boxRow + 1}, ${boxCol + 1}), number ${num} only appears in column ${positions[0][1] + 1}. Eliminates ${num} from other cells in that column.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findBoxLineReduction(grid) {
                for (let num = 1; num <= 6; num++) {
                    for (let row = 0; row < 6; row++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push([row, col]);
                            }
                        }
                        
                        if (positions.length >= 2) {
                            const boxCols = positions.map(([, c]) => Math.floor(c / 3));
                            if (boxCols.every(bc => bc === boxCols[0])) {
                                return {
                                    type: 'Box/Line Reduction',
                                    explanation: `In row ${row + 1}, number ${num} only appears in one box. Eliminates ${num} from other cells in that box.`,
                                    cells: positions,
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findXWing(grid) {
                for (let num = 1; num <= 6; num++) {
                    const rowPairs = [];
                    
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                cols.push(col);
                            }
                        }
                        if (cols.length === 2) {
                            rowPairs.push({ row, cols });
                        }
                    }
                    
                    for (let i = 0; i < rowPairs.length; i++) {
                        for (let j = i + 1; j < rowPairs.length; j++) {
                            if (rowPairs[i].cols[0] === rowPairs[j].cols[0] && 
                                rowPairs[i].cols[1] === rowPairs[j].cols[1]) {
                                return {
                                    type: 'X-Wing',
                                    explanation: `X-Wing: ${num} appears exactly twice in rows ${rowPairs[i].row + 1} and ${rowPairs[j].row + 1}, both in columns ${rowPairs[i].cols[0] + 1} and ${rowPairs[i].cols[1] + 1}. Eliminates ${num} from other cells in those columns.`,
                                    cells: [
                                        [rowPairs[i].row, rowPairs[i].cols[0]],
                                        [rowPairs[i].row, rowPairs[i].cols[1]],
                                        [rowPairs[j].row, rowPairs[j].cols[0]],
                                        [rowPairs[j].row, rowPairs[j].cols[1]]
                                    ],
                                    value: num
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findYWing(grid) {
                const allCandidates = {};
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) {
                                allCandidates[`${row}-${col}`] = { row, col, cands };
                            }
                        }
                    }
                }
                
                const biValueCells = Object.values(allCandidates);
                
                for (let i = 0; i < biValueCells.length; i++) {
                    const pivot = biValueCells[i];
                    for (let j = 0; j < biValueCells.length; j++) {
                        if (i === j) continue;
                        const wing1 = biValueCells[j];
                        
                        const sharedWithPivot = pivot.cands.filter(c => wing1.cands.includes(c));
                        if (sharedWithPivot.length !== 1) continue;
                        
                        for (let k = 0; k < biValueCells.length; k++) {
                            if (k === i || k === j) continue;
                            const wing2 = biValueCells[k];
                            
                            const sharedWithPivot2 = pivot.cands.filter(c => wing2.cands.includes(c));
                            if (sharedWithPivot2.length !== 1) continue;
                            if (sharedWithPivot2[0] === sharedWithPivot[0]) continue;
                            
                            const sharedBetweenWings = wing1.cands.filter(c => wing2.cands.includes(c));
                            if (sharedBetweenWings.length === 1) {
                                return {
                                    type: 'Y-Wing',
                                    explanation: `Y-Wing: Pivot at (${pivot.row + 1}, ${pivot.col + 1}) [${pivot.cands.join(',')}] connects two wings. Eliminates ${sharedBetweenWings[0]} from cells seeing both wings.`,
                                    cells: [
                                        [pivot.row, pivot.col],
                                        [wing1.row, wing1.col],
                                        [wing2.row, wing2.col]
                                    ],
                                    value: sharedBetweenWings[0]
                                };
                            }
                        }
                    }
                }
                return null;
            },

            // BUG (Bivalue Universal Grave) - if all unsolved cells have 2 candidates
            // except one cell with 3, that cell's value is the candidate appearing 3 times
            findBUG(grid) {
                const cellCandidates = [];
                let triValueCell = null;

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) {
                                cellCandidates.push({ row, col, cands });
                            } else if (cands.length === 3) {
                                if (triValueCell) return null; // More than one 3-candidate cell
                                triValueCell = { row, col, cands };
                            } else {
                                return null; // Cell with 1 or 4+ candidates breaks BUG pattern
                            }
                        }
                    }
                }

                if (!triValueCell) return null;

                // Find which candidate appears 3 times in row/col/box
                for (const cand of triValueCell.cands) {
                    // Count occurrences in row
                    let rowCount = 0;
                    for (let c = 0; c < 6; c++) {
                        if (grid[triValueCell.row][c] === 0) {
                            const cellCands = this.getCandidates(grid, triValueCell.row, c);
                            if (cellCands.includes(cand)) rowCount++;
                        }
                    }

                    // Count occurrences in column
                    let colCount = 0;
                    for (let r = 0; r < 6; r++) {
                        if (grid[r][triValueCell.col] === 0) {
                            const cellCands = this.getCandidates(grid, r, triValueCell.col);
                            if (cellCands.includes(cand)) colCount++;
                        }
                    }

                    // In a BUG, each candidate appears exactly twice in each unit
                    // The solution is the candidate that appears 3 times (odd count)
                    if (rowCount % 2 === 1 || colCount % 2 === 1) {
                        return {
                            type: 'BUG (Bivalue Universal Grave)',
                            row: triValueCell.row,
                            col: triValueCell.col,
                            value: cand,
                            explanation: `BUG detected! All cells have 2 candidates except (${triValueCell.row + 1}, ${triValueCell.col + 1}) with 3. The answer is ${cand} (appears odd number of times in its units).`,
                            cells: [[triValueCell.row, triValueCell.col]]
                        };
                    }
                }
                return null;
            },

            // Swordfish - like X-Wing but with 3 rows/columns
            findSwordfish(grid) {
                for (let num = 1; num <= 6; num++) {
                    // Find rows where num appears in exactly 2-3 positions
                    const rowData = [];
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                cols.push(col);
                            }
                        }
                        if (cols.length >= 2 && cols.length <= 3) {
                            rowData.push({ row, cols });
                        }
                    }

                    // Need at least 3 rows for Swordfish
                    if (rowData.length >= 3) {
                        // Try all combinations of 3 rows
                        for (let i = 0; i < rowData.length - 2; i++) {
                            for (let j = i + 1; j < rowData.length - 1; j++) {
                                for (let k = j + 1; k < rowData.length; k++) {
                                    const allCols = new Set([
                                        ...rowData[i].cols,
                                        ...rowData[j].cols,
                                        ...rowData[k].cols
                                    ]);
                                    // Swordfish: 3 rows share exactly 3 columns
                                    if (allCols.size === 3) {
                                        return {
                                            type: 'Swordfish',
                                            explanation: `Swordfish: ${num} in rows ${rowData[i].row + 1}, ${rowData[j].row + 1}, ${rowData[k].row + 1} is confined to columns ${[...allCols].map(c => c + 1).join(', ')}. Eliminates ${num} from other cells in those columns.`,
                                            cells: [
                                                ...rowData[i].cols.map(c => [rowData[i].row, c]),
                                                ...rowData[j].cols.map(c => [rowData[j].row, c]),
                                                ...rowData[k].cols.map(c => [rowData[k].row, c])
                                            ],
                                            value: num
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                return null;
            },

            handleNewGame() {
                if (this.currentMode === 'archive') {
                    this.backToArchive();
                } else {
                    this.newPuzzle();
                }
            },

            newPuzzle() {
                this.currentMode = 'random';
                this.currentLevelId = null;
                document.querySelector('.top-bar h1').textContent = 'Mini Sudoku';

                const { puzzle, solution } = this.generatePuzzle(this.difficulty);

                // Verify the puzzle is valid
                console.log('Generated puzzle:', puzzle);
                console.log('Solution:', solution);
                console.log('Difficulty:', this.difficulty);

                this.grid = puzzle.map(row => [...row]);
                this.initialGrid = puzzle.map(row => [...row]);
                this.solution = solution;
                this.selectedCell = null;
                this.notes = {};
                this.history = [];
                this.solveAttempts = [];
                this.timer = 0;
                this.isRunning = true;
                this.currentHint = null;
                this.highlightedCells = [];
                this.startTimer();
                this.render();
                this.hideMessage();
                this.updateTimerButton();
                document.getElementById('newGameBtn').classList.remove('show');
            },

            changeDifficulty(newDifficulty) {
                this.difficulty = newDifficulty;
                this.updateSettingsUI();
            },

            // Settings Modal
            openSettings() {
                this.updateSettingsUI();
                document.getElementById('settingsModal').classList.add('show');
            },

            closeSettings() {
                document.getElementById('settingsModal').classList.remove('show');
            },

            closeSettingsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeSettings();
                }
            },

            newPuzzleFromSettings() {
                this.closeSettings();
                this.newPuzzle();
            },

            updateSettingsUI() {
                // Update difficulty buttons
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.difficulty);
                });
                // Update hint buttons
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.hintLevel);
                });
                // Update timer button
                this.updateTimerButton();
            },

            updateTimerButton() {
                const btn = document.getElementById('timerToggleBtn');
                const text = document.getElementById('timerBtnText');
                if (btn && text) {
                    text.textContent = this.isRunning ? 'Pause' : 'Resume';
                    btn.classList.toggle('active', !this.isRunning);
                }
            },

            initSettingsListeners() {
                // Difficulty options
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.changeDifficulty(btn.dataset.value);
                    });
                });
                // Hint options
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setHintLevel(btn.dataset.value);
                    });
                });
            },

            startTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if (this.isRunning) {
                        this.timer++;
                        this.updateTimer();
                    }
                }, 1000);
            },

            toggleTimer() {
                this.isRunning = !this.isRunning;
                this.updateTimerButton();

                // Add/remove blur effect
                const grid = document.getElementById('grid');
                if (this.isRunning) {
                    grid.classList.remove('blurred');
                } else {
                    grid.classList.add('blurred');
                }
            },

            updateTimer() {
                const mins = Math.floor(this.timer / 60);
                const secs = this.timer % 60;
                document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            toggleNotes() {
                this.mode = this.mode === 'normal' ? 'notes' : 'normal';
                const notesBtn = document.getElementById('notesBtn');
                const notesStatus = document.getElementById('notesStatus');
                if (this.mode === 'notes') {
                    notesBtn.classList.add('active');
                    if (notesStatus) notesStatus.textContent = 'ON';
                } else {
                    notesBtn.classList.remove('active');
                    if (notesStatus) notesStatus.textContent = 'OFF';
                }
            },

            setHintLevel(level) {
                this.hintLevel = level;
                this.updateSettingsUI();
            },

            selectCell(row, col) {
                this.selectedCell = [row, col];
                this.render();
            },

            checkUnitComplete(row, col) {
                // Check if a row matches the solution
                const checkRow = (r) => {
                    for (let c = 0; c < 6; c++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a column matches the solution
                const checkCol = (c) => {
                    for (let r = 0; r < 6; r++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a box matches the solution
                const checkBox = (r, c) => {
                    const boxRow = Math.floor(r / 2) * 2;
                    const boxCol = Math.floor(c / 3) * 3;
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 3; j++) {
                            const br = boxRow + i;
                            const bc = boxCol + j;
                            if (this.grid[br][bc] !== this.solution[br][bc]) return false;
                        }
                    }
                    return true;
                };

                const completedUnits = [];

                // Check row
                if (checkRow(row)) {
                    completedUnits.push({ type: 'row', index: row });
                }

                // Check column
                if (checkCol(col)) {
                    completedUnits.push({ type: 'col', index: col });
                }

                // Check box
                if (checkBox(row, col)) {
                    const boxRow = Math.floor(row / 2) * 2;
                    const boxCol = Math.floor(col / 3) * 3;
                    completedUnits.push({ type: 'box', boxRow, boxCol });
                }

                // Animate completed units
                if (completedUnits.length > 0) {
                    this.animateCompletions(completedUnits);
                }
            },

            animateCompletions(units) {
                const cells = document.querySelectorAll('.cell');
                
                units.forEach(unit => {
                    if (unit.type === 'row') {
                        // Animate entire row
                        for (let col = 0; col < 6; col++) {
                            const cellIndex = unit.index * 6 + col;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'col') {
                        // Animate entire column
                        for (let row = 0; row < 6; row++) {
                            const cellIndex = row * 6 + unit.index;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'box') {
                        // Animate entire box
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = unit.boxRow + i;
                                const col = unit.boxCol + j;
                                const cellIndex = row * 6 + col;
                                cells[cellIndex].classList.add('complete-flash');
                                setTimeout(() => {
                                    cells[cellIndex].classList.remove('complete-flash');
                                }, 600);
                            }
                        }
                    }
                });
            },

            inputNumber(num) {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                if (this.mode === 'normal') {
                    // Save to history for undo
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: num,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });

                    this.grid[row][col] = num;
                    this.solveAttempts.push({ t: this.timer, correct: num === this.solution[row][col] });
                    delete this.notes[`${row}-${col}`];
                    this.render();
                    
                    // Check for completed units AFTER rendering
                    setTimeout(() => {
                        this.checkUnitComplete(row, col);
                        this.checkComplete();
                    }, 50);
                } else {
                    const key = `${row}-${col}`;
                    const cellNotes = this.notes[key] || [];
                    if (cellNotes.includes(num)) {
                        this.notes[key] = cellNotes.filter(n => n !== num);
                        if (this.notes[key].length === 0) delete this.notes[key];
                    } else {
                        this.notes[key] = [...cellNotes, num].sort();
                    }
                    this.render();
                }
            },

            undo() {
                if (this.history.length === 0) {
                    this.showMessage('Nothing to undo', 'info');
                    setTimeout(() => this.hideMessage(), 1500);
                    return;
                }

                const lastMove = this.history.pop();
                this.grid[lastMove.row][lastMove.col] = lastMove.oldValue;
                
                if (lastMove.oldNotes) {
                    this.notes[`${lastMove.row}-${lastMove.col}`] = lastMove.oldNotes;
                } else {
                    delete this.notes[`${lastMove.row}-${lastMove.col}`];
                }

                this.selectedCell = [lastMove.row, lastMove.col];
                this.render();
            },

            clearCell() {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                // Save to history for undo
                if (this.grid[row][col] !== 0) {
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: 0,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });
                }

                this.grid[row][col] = 0;
                delete this.notes[`${row}-${col}`];
                this.render();
            },

            getHint() {
                const hint = this.getSmartHint(this.grid);
                if (!hint) {
                    this.showMessage('No hints available!', 'info');
                    return;
                }

                this.currentHint = hint;
                this.highlightedCells = hint.cells || [];

                let message = '';
                if (this.hintLevel === 'strategy') {
                    message = `üí° Try: ${hint.type}`;
                } else if (this.hintLevel === 'location') {
                    message = `üí° ${hint.type}: Look at row ${hint.row + 1}, column ${hint.col + 1}`;
                } else {
                    message = `üí° ${hint.type}: ${hint.explanation}`;
                }

                this.showMessage(message, 'info');
                this.render();

                setTimeout(() => {
                    this.highlightedCells = [];
                    this.render();
                }, 5000);
            },

            applyHint() {
                if (!this.currentHint || this.currentHint.value === null) {
                    this.showMessage('Get a hint first!', 'info');
                    return;
                }

                this.grid[this.currentHint.row][this.currentHint.col] = this.currentHint.value;
                this.currentHint = null;
                this.highlightedCells = [];
                this.checkComplete();
                this.render();
                this.showMessage('Hint applied!', 'success');
                setTimeout(() => this.hideMessage(), 2000);
            },

            solveAll() {
                this.grid = this.solution.map(row => [...row]);
                this.isRunning = false;
                this.render();
                this.showMessage('Puzzle solved!', 'success');
            },

            applyHintFromSettings() {
                this.closeSettings();
                this.applyHint();
            },

            solveAllFromSettings() {
                this.closeSettings();
                this.solveAll();
            },

            checkComplete() {
                const isFilled = this.grid.every(row => row.every(cell => cell !== 0));
                if (isFilled) {
                    const isCorrect = this.grid.every((row, i) =>
                        row.every((cell, j) => cell === this.solution[i][j])
                    );
                    if (isCorrect) {
                        this.isRunning = false;
                        this.openSolveStats();
                        const timeStr = this.formatTime(this.timer);

                        if (this.currentMode === 'archive') {
                            // Archive mode completion
                            const progress = this.archiveProgress[this.currentLevelId];
                            const isNewRecord = !progress || !progress.bestTime || this.timer < progress.bestTime;

                            if (isNewRecord) {
                                this.archiveProgress[this.currentLevelId] = {
                                    bestTime: this.timer,
                                    completedAt: new Date().toISOString()
                                };
                                this.saveArchiveProgress();
                            }

                            let message = `üéâ Solved in ${timeStr}!`;
                            if (isNewRecord && progress && progress.bestTime) {
                                message += ' New Record!';
                            }
                            this.showMessage(message, 'success');

                            // Update button text for archive mode
                            const btn = document.getElementById('newGameBtn');
                            btn.textContent = 'Back to Levels';
                            btn.onclick = () => this.backToArchive();
                            btn.classList.add('show');
                        } else {
                            // Random mode completion
                            this.trackGameComplete(this.difficulty, this.timer);

                            const avg = this.getAverageTime(this.difficulty);
                            let message = `üéâ Solved in ${timeStr}!`;
                            if (avg) {
                                const diff = this.timer - avg;
                                const diffStr = this.formatTime(Math.abs(diff));
                                if (diff < 0) {
                                    message += ` (${diffStr} faster than avg)`;
                                } else if (diff > 0) {
                                    message += ` (${diffStr} slower than avg)`;
                                }
                            }
                            this.showMessage(message, 'success');

                            const btn = document.getElementById('newGameBtn');
                            btn.textContent = 'New Game';
                            btn.onclick = () => this.newPuzzle();
                            btn.classList.add('show');
                        }
                    } else {
                        this.showMessage('Some cells are incorrect!', 'error');
                        setTimeout(() => this.hideMessage(), 3000);
                    }
                }
            },

            showMessage(text, type) {
                const msg = document.getElementById('message');
                msg.textContent = text;
                msg.className = `message ${type}`;
                msg.style.display = 'block';
            },

            hideMessage() {
                document.getElementById('message').style.display = 'none';
            },

            showInstallInstructions() {
                // Check if already installed or dismissed
                if (window.matchMedia('(display-mode: standalone)').matches) {
                    return; // Already installed
                }

                if (localStorage.getItem('installBannerDismissed')) {
                    return; // User dismissed it
                }

                const banner = document.getElementById('installBanner');
                const instructions = document.getElementById('installInstructions');
                
                // Detect platform
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    instructions.innerHTML = 'üçé Safari: Tap <strong>Share</strong> ‚Üí <strong>Add to Home Screen</strong>';
                    banner.style.display = 'block';
                } else if (isAndroid) {
                    instructions.innerHTML = 'ü§ñ Chrome: Tap <strong>‚ãÆ</strong> menu ‚Üí <strong>Add to Home screen</strong>';
                    banner.style.display = 'block';
                } else {
                    // Desktop or other browsers
                    instructions.innerHTML = 'üíª Install this app for quick access!';
                    banner.style.display = 'block';
                }
            },

            dismissInstallBanner() {
                document.getElementById('installBanner').style.display = 'none';
                localStorage.setItem('installBannerDismissed', 'true');
            },

            // Check if a cell has a conflict (duplicate in row, column, or box)
            hasConflict(row, col) {
                const num = this.grid[row][col];
                if (num === 0) return false;

                // Check row for duplicates
                for (let c = 0; c < 6; c++) {
                    if (c !== col && this.grid[row][c] === num) return true;
                }

                // Check column for duplicates
                for (let r = 0; r < 6; r++) {
                    if (r !== row && this.grid[r][col] === num) return true;
                }

                // Check 2x3 box for duplicates
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        const r = boxRow + i;
                        const c = boxCol + j;
                        if ((r !== row || c !== col) && this.grid[r][c] === num) return true;
                    }
                }

                return false;
            },

            render() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';

                        const isGiven = this.initialGrid[row][col] !== 0;
                        const isSelected = this.selectedCell && this.selectedCell[0] === row && this.selectedCell[1] === col;
                        const isHighlighted = this.highlightedCells.some(([r, c]) => r === row && c === col);
                        const isConflict = this.hasConflict(row, col);

                        if (isGiven) cell.classList.add('given');
                        if (isSelected) cell.classList.add('selected');
                        if (isHighlighted) cell.classList.add('highlighted');
                        if (!isGiven && this.grid[row][col] !== 0) cell.classList.add('user-input');
                        if (isConflict) cell.classList.add('conflict');

                        const key = `${row}-${col}`;
                        const cellNotes = this.notes[key] || [];

                        if (cellNotes.length > 0 && this.grid[row][col] === 0) {
                            const notesDiv = document.createElement('div');
                            notesDiv.className = 'notes';
                            for (let num = 1; num <= 6; num++) {
                                const noteEl = document.createElement('div');
                                noteEl.className = 'note';
                                noteEl.textContent = cellNotes.includes(num) ? num : '';
                                notesDiv.appendChild(noteEl);
                            }
                            cell.appendChild(notesDiv);
                        } else if (this.grid[row][col] !== 0) {
                            cell.textContent = this.grid[row][col];
                        }

                        cell.onclick = () => this.selectCell(row, col);
                        gridEl.appendChild(cell);
                    }
                }
            }
        };

        window.onload = () => {
            app.init();

            // Show install instructions based on platform
            app.showInstallInstructions();

            // Keyboard input support
            document.addEventListener('keydown', (e) => {
                // Escape to close modals
                if (e.key === 'Escape') {
                    app.closeSettings();
                    app.closeStats();
                    app.closeSolveStats();
                    return;
                }
                // Don't handle other keys if modal is open
                if (document.getElementById('settingsModal').classList.contains('show') ||
                    document.getElementById('statsModal').classList.contains('show') ||
                    document.getElementById('solveStatsModal').classList.contains('show')) {
                    return;
                }
                // Number keys 1-6
                if (e.key >= '1' && e.key <= '6') {
                    app.inputNumber(parseInt(e.key));
                }
                // Backspace or Delete to clear
                else if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    app.clearCell();
                }
                // Arrow keys for navigation
                else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!app.selectedCell) {
                        app.selectCell(0, 0);
                    } else {
                        let [row, col] = app.selectedCell;
                        if (e.key === 'ArrowUp') row = Math.max(0, row - 1);
                        else if (e.key === 'ArrowDown') row = Math.min(5, row + 1);
                        else if (e.key === 'ArrowLeft') col = Math.max(0, col - 1);
                        else if (e.key === 'ArrowRight') col = Math.min(5, col + 1);
                        app.selectCell(row, col);
                    }
                }
                // N key to toggle notes mode
                else if (e.key === 'n' || e.key === 'N') {
                    app.toggleNotes();
                }
                // H key for hint
                else if (e.key === 'h' || e.key === 'H') {
                    app.getHint();
                }
                // Z key for undo (Ctrl/Cmd+Z)
                else if ((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    app.undo();
                }
            });

            // Register service worker for PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('Service Worker registered', reg))
                    .catch(err => console.log('Service Worker registration failed', err));
            }
        };
    </script>
</body>
</html>
