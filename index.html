<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a66c2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Mini Sudoku">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%230a66c2'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='280' fill='white' font-family='Arial'>6√ó6</text></svg>">
    <title>Mini Sudoku 6√ó6</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #f3f2ef;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 420px;
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        /* Top bar */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 8px;
        }

        .top-bar h1 {
            font-size: 18px;
            font-weight: 600;
            color: #000;
        }

        .top-bar-center {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: #666;
        }

        .top-bar-center .timer {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .settings-btn:active {
            background: #f5f5f5;
        }

        .menu-btn {
            padding: 6px;
            border: none;
            background: transparent;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        /* Grid */
        .grid-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            min-height: 0;
        }

        .sudoku-grid {
            display: inline-grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0;
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
            background: #444;
            transition: filter 0.3s ease;
        }

        .sudoku-grid.blurred {
            filter: blur(8px);
            pointer-events: none;
        }

        .cell {
            width: 52px;
            height: 52px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 500;
            cursor: pointer;
            position: relative;
            border: 0.5px solid #ccc;
            user-select: none;
            touch-action: manipulation;
        }

        .cell:active {
            background: #f0f0f0;
        }

        .cell.given {
            color: #000;
            background: white;
            font-weight: 600;
            cursor: default;
        }

        .cell.given.selected {
            box-shadow: inset 0 0 0 2px #00000040;
        }

        .cell.user-input {
            color: #666;
            font-weight: 500;
        }

        .cell.selected {
            background: #e8f0fe !important;
            box-shadow: inset 0 0 0 2px #1a73e8;
        }

        .cell.highlighted {
            background: #fff4cc;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { background: #fff4cc; }
            50% { background: #ffe999; }
        }

        .cell.complete-flash {
            animation: complete-flash 0.6s ease-out;
        }

        @keyframes complete-flash {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.given.complete-flash {
            animation: complete-flash-given 0.6s ease-out;
        }

        @keyframes complete-flash-given {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.user-input.complete-flash {
            animation: complete-flash-user 0.6s ease-out;
        }

        @keyframes complete-flash-user {
            0% { background: #10b981; }
            50% { background: #34d399; transform: scale(1.05); }
            100% { background: white; transform: scale(1); }
        }

        .cell.conflict {
            background: repeating-linear-gradient(
                45deg,
                #fff,
                #fff 4px,
                #ffcccc 4px,
                #ffcccc 8px
            ) !important;
            color: #c00 !important;
        }

        .cell.conflict.given {
            color: #c00 !important;
        }

        /* 2√ó3 block borders */
        .cell:nth-child(3),
        .cell:nth-child(9),
        .cell:nth-child(15),
        .cell:nth-child(21),
        .cell:nth-child(27),
        .cell:nth-child(33) {
            border-right: 2px solid #444;
        }

        .cell:nth-child(7),
        .cell:nth-child(8),
        .cell:nth-child(9),
        .cell:nth-child(10),
        .cell:nth-child(11),
        .cell:nth-child(12) {
            border-bottom: 2px solid #444;
        }

        .cell:nth-child(19),
        .cell:nth-child(20),
        .cell:nth-child(21),
        .cell:nth-child(22),
        .cell:nth-child(23),
        .cell:nth-child(24) {
            border-bottom: 2px solid #444;
        }

        .notes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
            padding: 3px;
        }

        .note {
            font-size: 11px;
            color: #00000066;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 400;
        }

        /* Action buttons */
        .action-bar {
            display: flex;
            justify-content: center;
            gap: 32px;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #666;
            font-size: 12px;
            font-weight: 500;
        }

        .action-btn:active {
            opacity: 0.7;
        }

        .action-btn.active {
            color: #1a73e8;
        }

        .action-btn .icon {
            font-size: 20px;
        }

        /* Number pad */
        .number-pad {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px 0;
            padding-bottom: 48px;
        }

        .number-btn {
            padding: 16px;
            font-size: 22px;
            font-weight: 500;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            color: #000;
            cursor: pointer;
            transition: all 0.15s;
        }

        .number-btn:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }

        .number-btn.action {
            font-size: 12px;
            color: #666;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .number-btn.action .icon {
            font-size: 18px;
        }

        .number-btn.completed {
            color: #ccc;
            border-color: #eee;
            background: #fafafa;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Message */
        .message {
            padding: 10px 16px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.4;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.info {
            background: #e8f4fd;
            color: #0c5460;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .modal-section {
            margin-bottom: 16px;
        }

        .modal-section label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .option-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            background: white;
            color: #333;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .option-btn.active {
            border-color: #1a73e8;
            background: #e8f0fe;
            color: #1a73e8;
        }

        .tactics-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .tactic-btn {
            padding: 4px 10px;
            border: 1.5px solid #ddd;
            border-radius: 20px;
            background: white;
            font-size: 12px;
            cursor: pointer;
            color: #555;
            transition: all 0.15s;
        }
        .tactic-btn.active {
            background: #1a73e8;
            border-color: #1a73e8;
            color: white;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .modal-btn.primary {
            background: #1a73e8;
            color: white;
        }

        .modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .stats-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f8f8f8;
            border-radius: 6px;
            font-size: 13px;
        }

        .stat-row .label {
            color: #333;
            font-weight: 500;
        }

        .stat-row .value {
            color: #666;
        }

        .stat-row .count {
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .stats-empty {
            color: #999;
            font-size: 13px;
            text-align: center;
            padding: 12px;
        }

        .stats-chart {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .stats-chart svg {
            width: 100%;
            height: auto;
        }

        .chart-summary {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            padding: 0 4px;
        }

        .chart-summary .stat {
            text-align: center;
        }

        .chart-summary .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .chart-summary .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #999;
        }

        .new-game-btn {
            display: none;
            width: 100%;
            padding: 14px;
            margin-top: 8px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .new-game-btn.show {
            display: block;
        }

        .new-game-btn:active {
            background: #1557b0;
        }

        /* Archive View */
        .archive-view {
            background: white;
            max-width: 420px;
            width: 100%;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .archive-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
            position: sticky;
            top: 0;
            z-index: 1;
            background: white;
        }

        .archive-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .archive-back-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            font-size: 14px;
            color: #1a73e8;
            cursor: pointer;
            font-weight: 500;
        }

        .archive-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
        }

        .archive-level {
            display: flex;
            align-items: center;
            padding: 16px;
            margin-bottom: 8px;
            background: #f8f8f8;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .archive-level:hover {
            background: #f0f0f0;
        }

        .archive-level:active {
            background: #e8e8e8;
        }

        .level-name {
            flex: 1;
            font-size: 16px;
            font-weight: 500;
        }

        .level-time {
            font-size: 14px;
            color: #666;
            margin-right: 12px;
            font-family: monospace;
        }

        .level-status {
            font-size: 16px;
            color: #10b981;
            width: 20px;
            text-align: center;
        }

        .archive-empty {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 360px) {
            .cell {
                width: 46px;
                height: 46px;
                font-size: 22px;
            }
        }

        @media (min-width: 400px) {
            .cell {
                width: 56px;
                height: 56px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1>Mini Sudoku</h1>
            <div class="top-bar-center">
                <div class="timer">
                    <span>‚è±</span>
                    <span id="timer">0:00</span>
                </div>
            </div>
            <div class="top-bar-right">
                <button class="menu-btn" onclick="app.openArchive()" title="Levels">üìö</button>
                <button class="menu-btn" onclick="app.openStats()" title="Stats">üìä</button>
                <button class="settings-btn" onclick="app.openSettings()">
                    Settings <span>‚ñæ</span>
                </button>
                <button class="menu-btn" onclick="app.handleNewGame()">‚ü≥</button>
            </div>
        </div>

        <!-- Install Banner (hidden by default) -->
        <div id="installBanner" style="display: none; background: #e8f4fd; border-radius: 8px; padding: 10px; margin-bottom: 8px; text-align: center;">
            <div style="font-size: 12px; color: #1a73e8;" id="installInstructions"></div>
            <button style="margin-top: 6px; padding: 4px 12px; border: none; background: #1a73e8; color: white; border-radius: 4px; font-size: 12px; cursor: pointer;" onclick="app.dismissInstallBanner()">Got it</button>
        </div>

        <!-- Message area -->
        <div id="message" style="display: none;"></div>
        <button class="new-game-btn" id="newGameBtn" onclick="app.newPuzzle()">New Game</button>

        <!-- Grid -->
        <div class="grid-wrapper">
            <div class="sudoku-grid" id="grid"></div>
        </div>

        <!-- Action Bar -->
        <div class="action-bar">
            <button class="action-btn" onclick="app.getHint()">
                <span class="icon">üí°</span>
                <span>Hint</span>
            </button>
            <button class="action-btn" id="notesBtn" onclick="app.toggleNotes()">
                <span class="icon">‚úèÔ∏è</span>
                <span>Notes <span id="notesStatus">OFF</span></span>
            </button>
        </div>

        <!-- Number Pad -->
        <div class="number-pad">
            <button class="number-btn" onclick="app.inputNumber(1)">1</button>
            <button class="number-btn" onclick="app.inputNumber(2)">2</button>
            <button class="number-btn" onclick="app.inputNumber(3)">3</button>
            <button class="number-btn action" onclick="app.clearCell()">
                <span class="icon">‚úï</span>
                <span>Erase</span>
            </button>
            <button class="number-btn" onclick="app.inputNumber(4)">4</button>
            <button class="number-btn" onclick="app.inputNumber(5)">5</button>
            <button class="number-btn" onclick="app.inputNumber(6)">6</button>
            <button class="number-btn action" onclick="app.undo()">
                <span class="icon">‚Ü∫</span>
                <span>Undo</span>
            </button>
        </div>
    </div>

    <!-- Archive View (full screen) -->
    <div class="archive-view" id="archiveView" style="display: none;">
        <div class="archive-header">
            <button class="archive-back-btn" onclick="app.closeArchive()">‚Üê Back</button>
            <h2>Levels</h2>
            <div style="width: 60px;"></div>
        </div>
        <div class="archive-list" id="archiveLevelList">
            <!-- Levels rendered dynamically -->
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal" onclick="app.closeStatsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 360px;">
            <h2>Stats</h2>

            <div class="modal-section">
                <label>Filter by Difficulty</label>
                <div class="option-group" id="statsFilterOptions">
                    <button class="option-btn active" data-value="all" onclick="app.filterStats('all')">All</button>
                    <button class="option-btn" data-value="easy" onclick="app.filterStats('easy')">Easy</button>
                    <button class="option-btn" data-value="medium" onclick="app.filterStats('medium')">Medium</button>
                    <button class="option-btn" data-value="hard" onclick="app.filterStats('hard')">Hard</button>
                    <button class="option-btn" data-value="expert" onclick="app.filterStats('expert')">Expert</button>
                    <button class="option-btn" data-value="ultra" onclick="app.filterStats('ultra')">Ultra</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Solve Time Progress</label>
                <div id="statsChart" class="stats-chart">
                    <svg id="chartSvg" viewBox="0 0 320 160"></svg>
                </div>
                <div id="chartSummary" class="chart-summary"></div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.resetStats()">Reset</button>
                <button class="modal-btn primary" onclick="app.closeStats()">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal" onclick="app.closeSettingsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <h2>Settings</h2>

            <div class="modal-section">
                <label>Difficulty</label>
                <div class="option-group" id="difficultyOptions">
                    <button class="option-btn" data-value="easy">Easy</button>
                    <button class="option-btn active" data-value="medium">Medium</button>
                    <button class="option-btn" data-value="hard">Hard</button>
                    <button class="option-btn" data-value="expert">Expert</button>
                    <button class="option-btn" data-value="ultra">Ultra</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Hint Detail</label>
                <div class="option-group" id="hintOptions">
                    <button class="option-btn" data-value="strategy">Strategy Only</button>
                    <button class="option-btn" data-value="location">+ Location</button>
                    <button class="option-btn active" data-value="full">Full Hint</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Hint Tactics <span style="font-weight:400;font-size:11px;color:#999;">‚Äî disable to practice yourself</span></label>
                <div id="tacticsOptions" class="tactics-grid">
                    <button class="tactic-btn" data-tactic="nakedSingle">Naked Single</button>
                    <button class="tactic-btn" data-tactic="hiddenSingle">Hidden Single</button>
                    <button class="tactic-btn" data-tactic="nakedPair">Naked Pair</button>
                    <button class="tactic-btn" data-tactic="pointingPair">Pointing Pair</button>
                    <button class="tactic-btn" data-tactic="boxLineReduction">Box-Line</button>
                    <button class="tactic-btn" data-tactic="xWing">X-Wing</button>
                    <button class="tactic-btn" data-tactic="yWing">Y-Wing</button>
                    <button class="tactic-btn" data-tactic="bug">BUG</button>
                    <button class="tactic-btn" data-tactic="swordfish">Swordfish</button>
                </div>
            </div>

            <div class="modal-section">
                <label>Timer</label>
                <div class="option-group">
                    <button class="option-btn" id="timerToggleBtn" onclick="app.toggleTimer()">
                        <span id="timerBtnText">Pause</span>
                    </button>
                </div>
            </div>

            <div class="modal-section">
                <label>Actions</label>
                <div class="option-group">
                    <button class="option-btn" onclick="app.applyHintFromSettings()">Apply Hint</button>
                    <button class="option-btn" onclick="app.solveAllFromSettings()">Solve All</button>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="app.closeSettings()">Close</button>
                <button class="modal-btn primary" onclick="app.newPuzzleFromSettings()">New Puzzle</button>
            </div>
        </div>
    </div>

    <!-- Solve Stats Modal -->
    <div class="modal-overlay" id="solveStatsModal" onclick="app.closeSolveStatsOnOverlay(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 360px;">
            <h2>Puzzle Complete</h2>
            <div class="modal-section">
                <div id="solveStatsSummary" class="chart-summary"></div>
            </div>
            <div class="modal-section">
                <label>Speed Over Time</label>
                <div class="stats-chart">
                    <svg id="solveChartSvg" viewBox="0 0 320 160"></svg>
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" id="nextLevelBtn" onclick="app.playNextLevel()" style="display: none;">Next Level</button>
                <button class="modal-btn primary" onclick="app.closeSolveStats()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const app = {
            grid: [],
            solution: [],
            initialGrid: [],
            selectedCell: null,
            mode: 'normal',
            notes: {},
            timer: 0,
            timerInterval: null,
            isRunning: true,
            hintLevel: 'full',
            currentHint: null,
            highlightedCells: [],
            history: [], // For undo functionality
            solveAttempts: [],   // [{ t: seconds, correct: bool }, ...]
            difficulty: 'medium',
            enabledTactics: {
                nakedSingle: true,
                hiddenSingle: true,
                nakedPair: true,
                pointingPair: true,
                boxLineReduction: true,
                xWing: true,
                yWing: true,
                bug: true,
                swordfish: true,
            },

            // Stats tracking
            stats: {
                gamesByDifficulty: {},  // { 'easy': [{time: 120, date: ...}, ...], ... }
            },
            statsFilter: 'all',

            // Archive mode
            currentMode: 'random',      // 'random' | 'archive'
            currentLevelId: null,
            archiveProgress: {},        // { "1": { bestTime: 145, completedAt: "..." }, ... }

            // Hardcoded archive levels (add your puzzles here)
            LEVELS: [
                { id: 1, grid: "123450050030004060000310500020000000", solution: "123456456132314265265314541623632541" },
                { id: 2, grid: "100005020030003500001400040050300006", solution: "134625526134463512251463642351315246" },
                { id: 3, grid: "123400500000600000000001000003004265", solution: "123456546312631524452631265143314265" },
                { id: 4, grid: "600001500003040020030050002400001600", solution: "623541514263145326236154362415451632" },
                { id: 5, grid: "003200040010050000060040001300000000", solution: "513264246513154632362145421356635421" },
                { id: 6, grid: "100000005230204005306004401003000000", solution: "132546645231214365356124421653563412" },
                { id: 7, grid: "000000012340040020050030036450000000", solution: "364215512346643521251634136452425163" },
                { id: 8, grid: "200000100400000502000003056000000056", solution: "245631163425631542524163356214412356" },
                { id: 9, grid: "000000123000045600000000006510000263", solution: "564132123456345621612345236514451263" },
                { id: 10, grid: "010000234000050000000306000040000205", solution: "615432234561356124142356521643463215" },
                { id: 11, grid: "000000012300004230000560000010500000", solution: "365142412356654231123564236415541623" },
                { id: 12, grid: "120000340000001200004300000012000063", solution: "125634346125531246264351653412412563" },
                { id: 13, grid: "000000010020020016030045040050002100", solution: "253461614523425316136245341652562134" },
                { id: 14, grid: "001200000340400056610003023000004500", solution: "341265256341432156615423523614164532" },
                { id: 15, grid: "000000230014450023000000100006023450", solution: "514362236514451623362145145236623451" },
                { id: 16, grid: "065400000020006500000010054200000000", solution: "265431431625316542542316154263623154" },
                { id: 17, grid: "001000020300400020050006003060000500", solution: "341652625341436125152436513264264513" },
                { id: 18, grid: "000000405030360510000000123450000000", solution: "236145415632362514541263123456654321" },
                { id: 19, grid: "010000203000040500006020000102000060", solution: "614253253614142536536421365142421365" },
                { id: 20, grid: "000000004500010060023450030010000000", solution: "352146164523415362623451536214241635" },
                { id: 21, grid: "001200003400120043340025004300002500", solution: "451236263451125643346125514362632514" },
                { id: 22, grid: "012000000230034000000450026000000120", solution: "312564645231534612261453126345453126" },
                { id: 23, grid: "005100010040000300006000034560000000", solution: "645123213645421356356214134562562431" },
                { id: 24, grid: "010000020050300060400100000300000000", solution: "514623623451351264462135245316136542" },
                { id: 25, grid: "000006000050000403003060020504104030", solution: "531246462351615423243165326514154632" },
                { id: 26, grid: "000500002000500030010002000400003000", solution: "431526652341526134314652265413143265" },
                { id: 27, grid: "450000000010000200003000040000000036", solution: "451362632514164253523641346125215436" },
                { id: 28, grid: "102030030102405060020501501020040605", solution: "152436634152415263326541561324243615" },
                { id: 29, grid: "123400000000034560000000002345000000", solution: "123456456123234561561234612345345612" },
                { id: 30, grid: "605000004000060005200040000300000201", solution: "635412124536463125251643512364346251" },
                { id: 31, grid: "000123000004000010030000200000345000", solution: "564123123654452316631542216435345261" },
                { id: 32, grid: "001200000030000304003005020000400000", solution: "351246264531512364643125126453435612" },
                { id: 33, grid: "600000300201000504000010030050040000", solution: "612345354261163524425613231456546132" },
                { id: 34, grid: "010000200050000400003000020006000041", solution: "514362236154652413143625421536365241" },
                { id: 35, grid: "120045340061560023001600002500003400", solution: "126345345261564123231654412536653412" },
                { id: 36, grid: "000000123000345000000345000214000000", solution: "654132123456345621261345536214412563" },
                { id: 37, grid: "100000200060340050050042010003000004", solution: "164235235461342156651342416523523614" },
                { id: 38, grid: "000003034502000001600000501230400000", solution: "256413134562345621612345561234423156" },
                { id: 39, grid: "034500200060100030020400002000001000", solution: "634521215364146235523416462153351642" },
                { id: 40, grid: "003400020050100006600003040020005100", solution: "513462426351132546654213341625265134" },
                { id: 41, grid: "000000002340010005030006050004001650", solution: "143562562341614235235416356124421653" },
                { id: 42, grid: "045600600050501040402300300004024560", solution: "245631613452531246462315356124124563" },
                { id: 43, grid: "000000060502050401020305001230000100", solution: "215643463512356421124365541236632154" },
                { id: 44, grid: "000000000056000140005600034000120000", solution: "653412241356362145415623534261126534" },
                { id: 45, grid: "012300000002100003300004500000006540", solution: "412365653412124653365124541236236541" },
                { id: 46, grid: "000000012340020050030000046020000000", solution: "463215512346624153135462346521251634" },
                { id: 47, grid: "000050000043001200003400230000040000", solution: "314652652143461235523461236514145326" },
                { id: 48, grid: "000001010200002030030400004005500060", solution: "253641416253142536635412364125521364" },
                { id: 49, grid: "230045100006002500004200400001560032", solution: "236145145326312564654213423651561432" },
                { id: 50, grid: "000060000501000403023005100030034100", solution: "541362362541615423423615156234234156" },
                { id: 51, grid: "000120230000000034450000000056045000", solution: "564123231645126534453261312456645312" },
                { id: 52, grid: "006000001000400001200004000300000600", solution: "546123321456465231213564654312132645" },
                { id: 53, grid: "000000100006230045000000003400050030", solution: "362514145326236145514263623451451632" },
                { id: 54, grid: "021340040000003000000500000030032410", solution: "521346346251253164164523415632632415" },
                { id: 55, grid: "100000000002000030000004004050020603", solution: "132465456312245136613524364251521643" },
                { id: 56, grid: "000400003520024036130240065310002000", solution: "251463643521524136136245465312312654" },
                { id: 57, grid: "023056450001600000000004200045340610", solution: "123456456231614523532164261345345612" },
                { id: 58, grid: "000000034500120650000000002460065013", solution: "251346634521123654546132312465465213" },
                { id: 59, grid: "003400020050100006004300050020000000", solution: "513462426153135246264315351624642531" },
                { id: 60, grid: "100000020030003600005400040050000006", solution: "134562526134413625265413642351351246" },
                { id: 61, grid: "001200000030030040020050010000005400", solution: "351264642531536142124356413625265413" },
                { id: 62, grid: "060010400003000600005000500002030040", solution: "263415451263324651615324546132132546" },
                { id: 63, grid: "000000006500065430032150210045650021", solution: "541263326514165432432156213645654321" },
                { id: 64, grid: "234000105000456000000456000601000532", solution: "234165165324456213312456523641641532" },
                { id: 65, grid: "100064300000003400006500000005240003", solution: "152364364152513426426531631245245613" },
                { id: 66, grid: "300004020050001600002100040060500003", solution: "365214124356451632632145243561516423" },
                { id: 67, grid: "000100001002030020050040500200004000", solution: "245136361452436521152643513264624315" },
                { id: 68, grid: "013000005310000050040000024600000240", solution: "413526265314631452542163124635356241" },
                { id: 69, grid: "003040000005500200002006300000060300", solution: "653142214635546213132456321564465321" },
                { id: 70, grid: "010000234000561040020165000432000010", solution: "615324234651561243423165156432342516" },
                { id: 71, grid: "123400000030610003002004300205040301", solution: "123456456132614523532614361245245361" },
                { id: 72, grid: "012000003400000000000120120034054000", solution: "412356563412231645645123126534354261" },
                { id: 73, grid: "003400020050010060004100000000001200", solution: "153426426351312564564132245613631245" },
                { id: 74, grid: "000104000200000023520000006000401000", solution: "362154145236614523523641236415451362" },
                { id: 75, grid: "012300000000600003300004000000005420", solution: "412365563142654213321654246531135426" },
                { id: 76, grid: "000060120000003000000200000043050000", solution: "435162126354263415541236612543354621" },
                { id: 77, grid: "010040234056000010060000650324040060", solution: "516243234156423615165432651324342561" },
                { id: 78, grid: "040100123450060200234560050300000000", solution: "645123123456561234234561456312312645" },
                { id: 79, grid: "000000040500301060200010100030000000", solution: "512643643521351264264315125436436152" },
                { id: 80, grid: "000000052610024000010300040020000001", solution: "631254452613324165516342143526265431" },
                { id: 81, grid: "005100040030200006030010020050010060", solution: "365124142635251346436512623451514263" },
                { id: 82, grid: "000000032100040020050060001530000000", solution: "614253532146146325253461461532325614" },
                { id: 83, grid: "010400020500030600002030003040004050", solution: "315462426513531624642135153246264351" },
                { id: 84, grid: "100034230560040000000002056023320040", solution: "165234234561542316613452456123321645" },
                { id: 85, grid: "350006410050000400003000020031100064", solution: "352146416352561423243615624531135264" },
                { id: 86, grid: "000561005002040003300050200600164000", solution: "432561615342546123321456253614164235" },
                { id: 87, grid: "000320004001005000000600500100032000", solution: "651324324561465213213645546132132456" },
                { id: 88, grid: "000000102030000004300000060402000000", solution: "635241142635216354354126563412421563" },
                { id: 89, grid: "000000040003001020030100200050000000", solution: "326514145263451326632145263451514632" },
                { id: 90, grid: "000000400050060400003000020600100020", solution: "615243432156561432243561324615156324" },
                { id: 91, grid: "012345000012000034450000261000345260", solution: "612345534612126534453126261453345261" },
                { id: 92, grid: "023400010023200004300005450010006540", solution: "623451514623265134341265452316136542" },
                { id: 93, grid: "000023002001034000000530200100650000", solution: "415623362451534216126534243165651342" },
                { id: 94, grid: "020000130420040001050030312005000310", solution: "426153135426243561651234312645564312" },
                { id: 95, grid: "300000020010100200006004040050000006", solution: "361542425613134265256134642351513426" },
                { id: 96, grid: "100000200006030005040030000040000000", solution: "163254254316631425542631316542425163" },
                { id: 97, grid: "001300050000300002100006000060006400", solution: "621354453621365142142536514263236415" },
                { id: 98, grid: "020000450123060004010065135040000030", solution: "321456456123563214214365135642642531" },
                { id: 99, grid: "120000340610000230034000052061000025", solution: "126543345612561234234156452361613425" },
                { id: 100, grid: "000012005634301256206300400000000000", solution: "634512125634341256256341463125512463" },
                { id: 101, grid: "003400020050100006005300060010200004", solution: "513462426153132546645321364215251634" },
                { id: 102, grid: "200050001000000020040000000300030004", solution: "264153351642513426642531426315135264" },
                { id: 103, grid: "000400003000020005100030000100005000", solution: "561423243561324615156234432156615342" },
                { id: 104, grid: "000000500001030020001400002500003600", solution: "316254524361435126261435642513153642" },
                { id: 105, grid: "123400605000210003300021000105001234", solution: "123456645312216543354621432165561234" },
                { id: 106, grid: "000000012340024130035260053610000000", solution: "346521512346624135135264453612261453" },
                { id: 107, grid: "000000012340005600000000020010034560", solution: "453126612345245631361254526413134562" },
                { id: 108, grid: "000000123000060205050403010050000020", solution: "546132123546364215251463612354435621" },
                { id: 109, grid: "100000006004200100003005300500000006", solution: "134652526314245163613425362541451236" },
                { id: 110, grid: "000600000540000032320000016000004000", solution: "453621162543645132321465216354534216" },
                { id: 111, grid: "100000040000200401000020005000060300", solution: "136245542136253461614523325614461352" },
                { id: 112, grid: "002060003012104000205641300000456100", solution: "512364643512164235235641321456456123" },
                { id: 113, grid: "001234003005002006005412030000200000", solution: "651234423165142356365412534621216543" },
                { id: 114, grid: "305000214000103000000123000040000256", solution: "365412214635123564546123652341431256" },
                { id: 115, grid: "543210620000106000200600300050000002", solution: "543216621543136425254631362154415362" },
                { id: 116, grid: "230000100000002300005400000006000045", solution: "236514154623462351315462541236623145" },
                { id: 117, grid: "001003000020000100004000030000200600", solution: "521463643521352146164352436215215634" },
                { id: 118, grid: "030500105000050004300020000206006040", solution: "234561165432652314341625413256526143" },
                { id: 119, grid: "016540002300400003600005004600063250", solution: "316542542316425163631425254631163254" },
                { id: 120, grid: "010040002300300004100005004600060050", solution: "613542452316325164146235534621261453" },
                { id: 121, grid: "000000100460204005306002400520000000", solution: "643251125463214635356142431526562314" },
                { id: 122, grid: "010050020040002100003600030060040010", solution: "314256625341462135153624531462246513" },
                { id: 123, grid: "001000020060300500004006030050000400", solution: "641235523164316542254316432651165423" },
                { id: 124, grid: "001200200000300005400001000006006400", solution: "641253253164312645465321124536536412" },
                { id: 125, grid: "006000005200130000060000000010000540", solution: "246135315264132456564321453612621543" },
                { id: 126, grid: "000056000340001200056000530004100023", solution: "423156615342341265256431532614164523" },
                { id: 127, grid: "650000004300000021420000006100000035", solution: "653214214356365421421563536142142635" },
                { id: 128, grid: "000000010000320010400320500400000500", solution: "253146614253325614461325532461146532" },
                { id: 129, grid: "030200005000123450006000040100000000", solution: "634215215634123456456321542163361542" },
                { id: 130, grid: "120000340000000064560000000045000023", solution: "125436346251213564564312632145451623" },
                { id: 131, grid: "000000005300040020030010120054000000", solution: "314265265341641523532416123654456132" },
                { id: 132, grid: "100000020005003040000100005000040000", solution: "156324324615513246462153235461641532" },
                { id: 133, grid: "000130130006004060060500600345345000", solution: "456132132456514263263514621345345621" },
                { id: 134, grid: "002310401020100030305040254000000000", solution: "562314431526146235325641254163613452" },
                { id: 135, grid: "000100004230000300006450031542000600", solution: "253164164235415326326451631542542613" },
                { id: 136, grid: "120005003010000200004000060400300056", solution: "126345453612615234234561561423342156" },
                { id: 137, grid: "000000100004020050300006001200004300", solution: "543612162534426153315426631245254361" },
                { id: 138, grid: "010000020005000006300000600030000040", solution: "516423423165254316361254642531135642" },
                { id: 139, grid: "102000030000405000000506000060000104", solution: "142653536412465231321546214365653124" },
                { id: 140, grid: "000000510032402305301204200003100006", solution: "623541514632462315351264246153135426" },
                { id: 141, grid: "123000040000050304060102000406000523", solution: "123645645231251364364152532416416523" },
                { id: 142, grid: "000000230045040030500002420051000000", solution: "654123231645142536563412426351315264" },
                { id: 143, grid: "120000030000400001510060000036000014", solution: "125643634125462351513462241536356214" },
                { id: 144, grid: "000000003450060000050031040200000100", solution: "524316613452361524452631145263236145" },
                { id: 145, grid: "100000000054000060040000230000000006", solution: "154632362154521463643215236541415326" },
                { id: 146, grid: "100200020030003004040050500600000000", solution: "135246426531253164641352514623362415" },
                { id: 147, grid: "000000015300060400034562000103000256", solution: "423615615324562431134562256143341256" },
                { id: 148, grid: "123000000000002460014500000000000235", solution: "123654546312352461614523235146461235" },
                { id: 149, grid: "000000001200003400450021360045000000", solution: "624513531264213456456321362145145632" },
                { id: 150, grid: "000000003400050040006200040020002600", solution: "164532523461251346436215645123312654" },
                { id: 151, grid: "120000000300200060030005004000000031", solution: "123654456312245163631245314526562431" },
                { id: 152, grid: "000004010200000030040000003010500000", solution: "235164614253152436346521423615561342" },
                { id: 153, grid: "600000003200040010050000030020001500", solution: "624351513264342615156432435126261543" },
                { id: 154, grid: "000610013020060030050140140350230000", solution: "524613613524461235352146146352235461" },
                { id: 155, grid: "010000020450035040040230053020000010", solution: "514362326451235146641235153624462513" },
                { id: 156, grid: "000123000004000050010000300000524000", solution: "456123132564243651615432361245524316" },
                { id: 157, grid: "000001000002010203602040400000200000", solution: "326451145632514263632145451326263514" },
                { id: 158, grid: "050006406050000400020001103020000300", solution: "352146416253531462624531143625265314" },
                { id: 159, grid: "000000043120000060050000016430000000", solution: "162354543126324561651243216435435612" },
                { id: 160, grid: "012300030000004000000600000020023100", solution: "412365635412364251251634146523523146" },
                { id: 161, grid: "020000130246040605050324060002000003", solution: "426531135246243615651324364152512463" },
                { id: 162, grid: "123450500001050004004003000102000035", solution: "123456546321351264264513635142412635" },
                { id: 163, grid: "000000012340003450000620300010450000", solution: "534162612345263451145623326514451236" },
                { id: 164, grid: "650000040000300052210006000040000025", solution: "653214142563364152215436526341431625" },
                { id: 165, grid: "001300004200050030600004030050000000", solution: "521346364215452631613524136452245163" },
                { id: 166, grid: "000300100040020005003000500400060050", solution: "245316136542421635653124512463364251" },
                { id: 167, grid: "030000105002301040050006000060000004", solution: "236451145632361245452316524163613524" },
                { id: 168, grid: "520000160000005416001003002004006235", solution: "523641164352235416641523352164416235" },
                { id: 169, grid: "520000160000000056000003002004006235", solution: "524361163542231456645123352614416235" },
                { id: 170, grid: "000000100560230010040053056001000000", solution: "564132123564235416641253456321312645" },
                { id: 171, grid: "000000001600020040300002040050056130", solution: "562413431625625341314562143256256134" },
                { id: 172, grid: "000100003200054020060530005400006000", solution: "642153513246354621261534135462426315" },
                { id: 173, grid: "004000030500400030200050010400002000", solution: "524361136542451236263154615423342615" },
                { id: 174, grid: "000120000003030040050010500000062000", solution: "345126126453231645654312513264462531" },
                { id: 175, grid: "102300000004020065456000030021000043", solution: "142356563214321465456132634521215643" },
                { id: 176, grid: "003400020050010060004500030040200001", solution: "153426426153512364364512631245245631" },
                { id: 177, grid: "000000520041030020000000100005260034", solution: "314652526341431526652413143265265134" },
                { id: 178, grid: "010040002300600004050030040020300001", solution: "513642462315631254254136146523325461" },
                { id: 179, grid: "120000003400000050000060005100640000", solution: "124635563412316254452361235146641523" },
                { id: 180, grid: "000000040162030005400030352040000000", solution: "621354543162236415415236352641164523" },
                { id: 181, grid: "100060020005300040004000000500006000", solution: "145263623415351642264351412536536124" },
                { id: 182, grid: "000000123450300060500010400020216540", solution: "654132123456341265562314435621216543" },
                { id: 183, grid: "000000000123002010010500423000000000", solution: "231465654123542316316542423651165234" },
                { id: 184, grid: "000500004030005020020001012345000000", solution: "231564564132145623326451612345453216" },
                { id: 185, grid: "010000024000030600040020052164000000", solution: "613452524316235641146523352164461235" },
                { id: 186, grid: "000050010004500003400002300010020000", solution: "243651615324562143431562354216126435" },
                { id: 187, grid: "000000020600301060600010060500004000", solution: "436152125634341265652413263541514326" },
                { id: 188, grid: "001000000103000020030000204000000500", solution: "361254425163146325532416254631613542" },
                { id: 189, grid: "002300406501500002003100300004014250", solution: "152346436521561432243165325614614253" },
                { id: 190, grid: "060100010200023400000000100020234510", solution: "362145415263623451541632156324234516" },



            ],

            init() {
                this.loadStats();
                this.loadTactics();
                this.loadArchiveProgress();
                const savedDifficulty = localStorage.getItem('sudokuDifficulty');
                if (savedDifficulty) this.difficulty = savedDifficulty;
                this.initSettingsListeners();
                this.newPuzzle();
            },

            loadStats() {
                try {
                    const saved = localStorage.getItem('sudokuStats');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        this.stats = {
                            gamesByDifficulty: parsed.gamesByDifficulty || {}
                        };
                    }
                } catch (e) {
                    console.error('Failed to load stats:', e);
                    this.stats = { gamesByDifficulty: {} };
                }
            },

            saveStats() {
                try {
                    localStorage.setItem('sudokuStats', JSON.stringify(this.stats));
                } catch (e) {
                    console.error('Failed to save stats:', e);
                }
            },

            loadTactics() {
                try {
                    const saved = localStorage.getItem('sudokuTactics');
                    if (saved) Object.assign(this.enabledTactics, JSON.parse(saved));
                } catch (e) {}
            },
            saveTactics() {
                try {
                    localStorage.setItem('sudokuTactics', JSON.stringify(this.enabledTactics));
                } catch (e) {}
            },

            // Archive functions
            loadArchiveProgress() {
                try {
                    const saved = localStorage.getItem('archiveProgress');
                    if (saved) {
                        this.archiveProgress = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Failed to load archive progress:', e);
                    this.archiveProgress = {};
                }
            },

            saveArchiveProgress() {
                try {
                    localStorage.setItem('archiveProgress', JSON.stringify(this.archiveProgress));
                } catch (e) {
                    console.error('Failed to save archive progress:', e);
                }
            },

            encodeGrid(grid) {
                return grid.map(row => row.join('')).join('');
            },

            decodeGrid(str) {
                const grid = [];
                for (let i = 0; i < 6; i++) {
                    const row = [];
                    for (let j = 0; j < 6; j++) {
                        row.push(parseInt(str[i * 6 + j]) || 0);
                    }
                    grid.push(row);
                }
                return grid;
            },

            openArchive() {
                document.querySelector('.container').style.display = 'none';
                document.getElementById('archiveView').style.display = 'flex';
                this.renderArchiveList();
                this.scrollToNextUnplayed();
            },

            closeArchive() {
                document.getElementById('archiveView').style.display = 'none';
                document.querySelector('.container').style.display = 'flex';
            },

            scrollToNextUnplayed() {
                const list = document.getElementById('archiveLevelList');
                const firstUnplayed = this.LEVELS.find(l => {
                    const progress = this.archiveProgress[l.id];
                    return !progress || !progress.bestTime;
                });
                const targetId = firstUnplayed ? firstUnplayed.id - 2 : 1;
                const targetEl = list.querySelector(`[data-level-id="${targetId}"]`);
                if (targetEl) {
                    targetEl.scrollIntoView({ block: 'start', behavior: 'instant' });
                }
            },

            renderArchiveList() {
                const list = document.getElementById('archiveLevelList');
                if (this.LEVELS.length === 0) {
                    list.innerHTML = '<div class="archive-empty">No levels yet. Use creator.html to add puzzles.</div>';
                    return;
                }

                list.innerHTML = this.LEVELS.map(level => {
                    const progress = this.archiveProgress[level.id];
                    const completed = progress && progress.bestTime;
                    const timeStr = completed ? this.formatTime(progress.bestTime) : '--:--';
                    return `
                        <div class="archive-level" data-level-id="${level.id}" onclick="app.playLevel(${level.id})">
                            <span class="level-name">Level ${level.id}</span>
                            <span class="level-time">${timeStr}</span>
                            <span class="level-status">${completed ? '‚úì' : ''}</span>
                        </div>
                    `;
                }).join('');
            },

            playLevel(id) {
                const level = this.LEVELS.find(l => l.id === id);
                if (!level) return;

                this.currentMode = 'archive';
                this.currentLevelId = id;
                this.grid = this.decodeGrid(level.grid);
                this.initialGrid = this.decodeGrid(level.grid);
                this.solution = this.decodeGrid(level.solution);
                this.selectedCell = null;
                this.notes = {};
                this.history = [];
                this.solveAttempts = [];
                this.timer = 0;
                this.isRunning = true;
                this.currentHint = null;
                this.highlightedCells = [];

                this.closeArchive();
                this.startTimer();
                this.render();
                this.hideMessage();
                document.getElementById('newGameBtn').classList.remove('show');

                // Update header to show level
                document.querySelector('.top-bar h1').textContent = `Level ${id}`;
            },

            backToArchive() {
                this.currentMode = 'random';
                this.currentLevelId = null;
                document.querySelector('.top-bar h1').textContent = 'Mini Sudoku';
                document.getElementById('newGameBtn').classList.remove('show');
                this.hideMessage();
                this.openArchive();
            },

            trackGameComplete(difficulty, time, cspm) {
                if (!this.stats.gamesByDifficulty[difficulty]) {
                    this.stats.gamesByDifficulty[difficulty] = [];
                }
                this.stats.gamesByDifficulty[difficulty].push({
                    time,
                    cspm,
                    date: new Date().toISOString()
                });
                // Keep only last 50 games per difficulty
                if (this.stats.gamesByDifficulty[difficulty].length > 50) {
                    this.stats.gamesByDifficulty[difficulty].shift();
                }
                this.saveStats();
            },

            getAverageTime(difficulty) {
                const games = this.stats.gamesByDifficulty[difficulty];
                if (!games || games.length === 0) return null;
                const total = games.reduce((sum, g) => sum + g.time, 0);
                return Math.round(total / games.length);
            },

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            openStats() {
                this.statsFilter = 'all';
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
                document.getElementById('statsModal').classList.add('show');
            },

            closeStats() {
                document.getElementById('statsModal').classList.remove('show');
            },

            closeStatsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeStats();
                }
            },

            openSolveStats() {
                this.renderSolveStatsChart();
                const nextLevelBtn = document.getElementById('nextLevelBtn');
                const hasNext = this.currentMode === 'archive' &&
                    this.currentLevelId != null &&
                    this.LEVELS.some(l => l.id === this.currentLevelId + 1);
                nextLevelBtn.style.display = hasNext ? '' : 'none';
                document.getElementById('solveStatsModal').classList.add('show');
            },

            playNextLevel() {
                this.closeSolveStats();
                this.playLevel(this.currentLevelId + 1);
            },

            closeSolveStats() {
                document.getElementById('solveStatsModal').classList.remove('show');
            },

            closeSolveStatsOnOverlay(event) {
                if (event.target === event.currentTarget) this.closeSolveStats();
            },

            renderSolveStatsChart() {
                const attempts = this.solveAttempts;
                const svg = document.getElementById('solveChartSvg');
                const summary = document.getElementById('solveStatsSummary');

                const totalInputs = attempts.length;
                const correctInputs = attempts.filter(a => a.correct).length;
                const accuracy = totalInputs > 0 ? Math.round((correctInputs / totalInputs) * 100) : 0;
                const cspm = this.timer > 0 ? Math.round((correctInputs / this.timer) * 60 * 10) / 10 : 0;

                summary.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(this.timer)}</div>
                        <div class="stat-label">Solve Time</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${accuracy}%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${cspm}</div>
                        <div class="stat-label">CSPM</div>
                    </div>`;

                if (attempts.length === 0) {
                    svg.innerHTML = '<text x="160" y="85" text-anchor="middle" fill="#999" font-size="13">No inputs recorded</text>';
                    return;
                }

                // Compute rolling CSPM at each attempt
                const points = [];
                let correctSoFar = 0;
                attempts.forEach(a => {
                    if (a.correct) correctSoFar++;
                    const rollingCspm = a.t > 0 ? (correctSoFar / a.t) * 60 : (a.correct ? 60 : 0);
                    points.push({ t: a.t, cspm: rollingCspm, correct: a.correct });
                });

                // Chart dimensions
                const width = 320, height = 160;
                const pad = { top: 20, right: 20, bottom: 30, left: 45 };
                const cw = width - pad.left - pad.right;
                const ch = height - pad.top - pad.bottom;

                const maxT = Math.max(...points.map(p => p.t), 1);
                const maxC = Math.max(...points.map(p => p.cspm), 1);
                const xScale = t => pad.left + (t / maxT) * cw;
                const yScale = c => pad.top + ch - (c / (maxC * 1.1)) * ch;

                let svgContent = '';

                // Grid lines + Y labels
                for (let i = 0; i <= 4; i++) {
                    const val = (maxC * 1.1) * (i / 4);
                    const y = yScale(val);
                    svgContent += `<line x1="${pad.left}" y1="${y}" x2="${width - pad.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>`;
                    svgContent += `<text x="${pad.left - 5}" y="${y + 4}" text-anchor="end" fill="#999" font-size="10">${Math.round(val)}</text>`;
                }

                // X-axis
                svgContent += `<line x1="${pad.left}" y1="${height - pad.bottom}" x2="${width - pad.right}" y2="${height - pad.bottom}" stroke="#ccc" stroke-width="1"/>`;
                svgContent += `<text x="${width / 2}" y="${height - 8}" text-anchor="middle" fill="#999" font-size="10">Time (seconds)</text>`;
                svgContent += `<text x="${pad.left - 38}" y="${pad.top + ch / 2}" text-anchor="middle" fill="#999" font-size="10" transform="rotate(-90,${pad.left - 38},${pad.top + ch / 2})">CSPM</text>`;

                // Line path
                if (points.length > 1) {
                    let d = `M ${xScale(points[0].t)} ${yScale(points[0].cspm)}`;
                    for (let i = 1; i < points.length; i++) {
                        d += ` L ${xScale(points[i].t)} ${yScale(points[i].cspm)}`;
                    }
                    svgContent += `<path d="${d}" fill="none" stroke="#1a73e8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                }

                // Dots: green = correct, red = incorrect
                points.forEach(p => {
                    const color = p.correct ? '#10b981' : '#ef4444';
                    svgContent += `<circle cx="${xScale(p.t)}" cy="${yScale(p.cspm)}" r="4" fill="${color}" stroke="white" stroke-width="1.5"/>`;
                });

                svg.innerHTML = svgContent;
            },

            resetStats() {
                if (confirm('Reset all stats? This cannot be undone.')) {
                    this.stats = { gamesByDifficulty: {} };
                    this.saveStats();
                    this.updateStatsDisplay();
                }
            },

            filterStats(difficulty) {
                this.statsFilter = difficulty;
                this.updateStatsFilterUI();
                this.updateStatsDisplay();
            },

            updateStatsFilterUI() {
                document.querySelectorAll('#statsFilterOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.statsFilter);
                });
            },

            getFilteredGames() {
                const difficulties = this.statsFilter === 'all'
                    ? ['easy', 'medium', 'hard', 'expert', 'ultra']
                    : [this.statsFilter];

                let games = [];
                difficulties.forEach(diff => {
                    const diffGames = this.stats.gamesByDifficulty[diff] || [];
                    diffGames.forEach((g, i) => {
                        games.push({ ...g, difficulty: diff, index: i });
                    });
                });

                // Sort by date
                games.sort((a, b) => new Date(a.date) - new Date(b.date));
                return games;
            },

            updateStatsDisplay() {
                const games = this.getFilteredGames();
                const svg = document.getElementById('chartSvg');
                const summary = document.getElementById('chartSummary');

                if (games.length === 0) {
                    svg.innerHTML = '<text x="160" y="85" text-anchor="middle" fill="#999" font-size="13">No games completed yet</text>';
                    summary.innerHTML = '';
                    return;
                }

                // Chart dimensions
                const width = 320;
                const height = 160;
                const padding = { top: 20, right: 20, bottom: 30, left: 45 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                // Calculate scales
                const times = games.map(g => g.time);
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                const timeRange = maxTime - minTime || 60;
                const yMin = Math.max(0, minTime - timeRange * 0.1);
                const yMax = maxTime + timeRange * 0.1;

                const xScale = (i) => padding.left + (i / (games.length - 1 || 1)) * chartWidth;
                const yScale = (t) => padding.top + chartHeight - ((t - yMin) / (yMax - yMin)) * chartHeight;

                // Build SVG
                let svgContent = '';

                // Y-axis labels
                const yTicks = 4;
                for (let i = 0; i <= yTicks; i++) {
                    const val = yMin + (yMax - yMin) * (i / yTicks);
                    const y = yScale(val);
                    svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>`;
                    svgContent += `<text x="${padding.left - 5}" y="${y + 4}" text-anchor="end" fill="#999" font-size="10">${this.formatTime(Math.round(val))}</text>`;
                }

                // X-axis
                svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="#ccc" stroke-width="1"/>`;
                svgContent += `<text x="${width / 2}" y="${height - 8}" text-anchor="middle" fill="#999" font-size="10">Games (${games.length})</text>`;

                // Line path
                if (games.length > 1) {
                    let pathD = `M ${xScale(0)} ${yScale(games[0].time)}`;
                    for (let i = 1; i < games.length; i++) {
                        pathD += ` L ${xScale(i)} ${yScale(games[i].time)}`;
                    }
                    svgContent += `<path d="${pathD}" fill="none" stroke="#1a73e8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                }

                // Points
                const diffColors = { easy: '#10b981', medium: '#f59e0b', hard: '#ef4444', expert: '#8b5cf6', ultra: '#ec4899' };
                games.forEach((g, i) => {
                    const color = diffColors[g.difficulty] || '#1a73e8';
                    svgContent += `<circle cx="${xScale(i)}" cy="${yScale(g.time)}" r="4" fill="${color}" stroke="white" stroke-width="1.5"/>`;
                });

                svg.innerHTML = svgContent;

                // Summary stats
                const avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                const bestTime = Math.min(...times);
                const latestTime = times[times.length - 1];

                // Average CSPM for the filtered games
                const gamesWithCspm = games.filter(g => g.cspm != null);
                const avgCspm = gamesWithCspm.length > 0
                    ? Math.round(gamesWithCspm.reduce((s, g) => s + g.cspm, 0) / gamesWithCspm.length * 10) / 10
                    : 0;

                summary.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(bestTime)}</div>
                        <div class="stat-label">Best</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(avgTime)}</div>
                        <div class="stat-label">Average</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${this.formatTime(latestTime)}</div>
                        <div class="stat-label">Latest</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${games.length}</div>
                        <div class="stat-label">Games</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${avgCspm}</div>
                        <div class="stat-label">Avg CSPM</div>
                    </div>
                `;
            },

            isValid(grid, row, col, num) {
                for (let x = 0; x < 6; x++) {
                    if (grid[row][x] === num) return false;
                    if (grid[x][col] === num) return false;
                }
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[boxRow + i][boxCol + j] === num) return false;
                    }
                }
                return true;
            },

            solve(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (this.solve(grid)) return true;
                                    grid[row][col] = 0;
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            },

            // Count solutions (stops at 2 since we only need to know if unique)
            countSolutions(grid, count = { value: 0 }) {
                if (count.value >= 2) return count.value; // Early exit if multiple found

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 6; num++) {
                                if (this.isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    this.countSolutions(grid, count);
                                    grid[row][col] = 0;
                                    if (count.value >= 2) return count.value;
                                }
                            }
                            return count.value;
                        }
                    }
                }
                count.value++;
                return count.value;
            },

            hasUniqueSolution(grid) {
                const gridCopy = grid.map(row => [...row]);
                return this.countSolutions(gridCopy) === 1;
            },

            generatePuzzle(difficulty = 'medium') {
                const grid = Array(6).fill(null).map(() => Array(6).fill(0));

                // Fill the first row with random numbers
                const firstRow = [1, 2, 3, 4, 5, 6].sort(() => Math.random() - 0.5);
                for (let col = 0; col < 6; col++) {
                    grid[0][col] = firstRow[col];
                }

                // Solve the rest
                this.solve(grid);
                const solution = grid.map(row => [...row]);

                const cellsToRemove = {
                    easy: 12,      // More clues = easier
                    medium: 18,    // Moderate clues
                    hard: 22,      // Fewer clues = harder
                    expert: 24,    // Very few clues
                    ultra: 27      // Extreme - requires X-Wing, Y-Wing, BUG
                }[difficulty] || 18;

                // Collect all cell positions and shuffle them
                const positions = [];
                for (let r = 0; r < 6; r++) {
                    for (let c = 0; c < 6; c++) {
                        positions.push([r, c]);
                    }
                }
                // Shuffle positions randomly
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                let removed = 0;

                // Try to remove cells while maintaining unique solution
                for (const [row, col] of positions) {
                    if (removed >= cellsToRemove) break;

                    const backup = grid[row][col];
                    grid[row][col] = 0;

                    // Check if puzzle still has unique solution
                    if (this.hasUniqueSolution(grid)) {
                        removed++;
                    } else {
                        // Restore the cell - removing it creates multiple solutions
                        grid[row][col] = backup;
                    }
                }

                console.log(`Generated ${difficulty} puzzle: removed ${removed}/${cellsToRemove} cells (unique solution guaranteed)`);
                return { puzzle: grid, solution };
            },

            getCandidates(grid, row, col) {
                if (grid[row][col] !== 0) return [];
                const candidates = [];
                for (let num = 1; num <= 6; num++) {
                    if (this.isValid(grid, row, col, num)) {
                        candidates.push(num);
                    }
                }
                return candidates;
            },

            findNakedSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            if (candidates.length === 1) {
                                return {
                                    type: 'Naked Single',
                                    row, col,
                                    value: candidates[0],
                                    explanation: `Cell (${row + 1}, ${col + 1}) can only be ${candidates[0]}. All other numbers are eliminated by existing numbers in its row, column, and box.`,
                                    cells: [[row, col]]
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findHiddenSingle(grid) {
                for (let row = 0; row < 6; row++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(col);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Row)',
                                row, col: positions[0],
                                value: num,
                                explanation: `In row ${row + 1}, the number ${num} can only go in column ${positions[0] + 1}.`,
                                cells: [[row, positions[0]]]
                            };
                        }
                    }
                }

                for (let col = 0; col < 6; col++) {
                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                positions.push(row);
                            }
                        }
                        if (positions.length === 1) {
                            return {
                                type: 'Hidden Single (Column)',
                                row: positions[0], col,
                                value: num,
                                explanation: `In column ${col + 1}, the number ${num} can only go in row ${positions[0] + 1}.`,
                                cells: [[positions[0], col]]
                            };
                        }
                    }
                }

                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 2) * 2;
                    const boxCol = (boxIdx % 2) * 3;

                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }
                        if (positions.length === 1) {
                            const [r, c] = positions[0];
                            return {
                                type: 'Hidden Single (Box)',
                                row: r, col: c,
                                value: num,
                                explanation: `In box ${boxIdx + 1}, ${num} can only go in one cell: row ${r + 1}, column ${c + 1}.`,
                                cells: positions
                            };
                        }
                    }
                }
                return null;
            },

            getSmartHint(grid) {
                const t = this.enabledTactics;

                if (t.nakedSingle)  { const h = this.findNakedSingle(grid);  if (h) return h; }
                if (t.hiddenSingle) { const h = this.findHiddenSingle(grid); if (h) return h; }

                if (this.difficulty !== 'easy') {
                    if (t.nakedPair)        { const h = this.findNakedPair(grid);        if (h) return h; }
                    if (t.pointingPair)     { const h = this.findPointingPair(grid);     if (h) return h; }
                    if (t.boxLineReduction) { const h = this.findBoxLineReduction(grid); if (h) return h; }
                }

                if (['hard', 'expert', 'ultra'].includes(this.difficulty)) {
                    if (t.xWing) { const h = this.findXWing(grid); if (h) return h; }
                }

                if (['expert', 'ultra'].includes(this.difficulty)) {
                    if (t.yWing) { const h = this.findYWing(grid); if (h) return h; }
                }

                if (this.difficulty === 'ultra') {
                    if (t.bug)       { const h = this.findBUG(grid);       if (h) return h; }
                    if (t.swordfish) { const h = this.findSwordfish(grid); if (h) return h; }
                }

                // Fallback
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const candidates = this.getCandidates(grid, row, col);
                            const difficultyHints = {
                                'expert': ' Try X-Wing or Y-Wing patterns.',
                                'ultra': ' Try BUG, Swordfish, or advanced chains.'
                            };
                            return {
                                type: 'General Hint',
                                row, col,
                                value: null,
                                explanation: `Cell (${row + 1}, ${col + 1}) has ${candidates.length} candidates: ${candidates.join(', ')}.${difficultyHints[this.difficulty] || ''}`,
                                cells: [[row, col]]
                            };
                        }
                    }
                }
                return null;
            },

            findNakedPair(grid) {
                const biValueCells = [];
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) biValueCells.push({ row, col, cands });
                        }
                    }
                }

                for (let i = 0; i < biValueCells.length; i++) {
                    for (let j = i + 1; j < biValueCells.length; j++) {
                        const a = biValueCells[i], b = biValueCells[j];
                        if (a.cands[0] !== b.cands[0] || a.cands[1] !== b.cands[1]) continue;
                        const [v1, v2] = a.cands;

                        // Same row?
                        if (a.row === b.row) {
                            const eliminated = [];
                            for (let c = 0; c < 6; c++) {
                                if (c === a.col || c === b.col) continue;
                                if (grid[a.row][c] === 0) {
                                    const cands = this.getCandidates(grid, a.row, c);
                                    if (cands.includes(v1) || cands.includes(v2)) eliminated.push([a.row, c]);
                                }
                            }
                            if (eliminated.length > 0) {
                                const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                return {
                                    type: 'Naked Pair',
                                    explanation: `Naked Pair [${v1},${v2}] in row ${a.row+1} at columns ${a.col+1} and ${b.col+1}. These cells must hold ${v1} and ${v2} ‚Äî eliminating both from ${elimStr}.`,
                                    cells: [[a.row, a.col], [b.row, b.col], ...eliminated],
                                    values: a.cands
                                };
                            }
                        }

                        // Same column?
                        if (a.col === b.col) {
                            const eliminated = [];
                            for (let r = 0; r < 6; r++) {
                                if (r === a.row || r === b.row) continue;
                                if (grid[r][a.col] === 0) {
                                    const cands = this.getCandidates(grid, r, a.col);
                                    if (cands.includes(v1) || cands.includes(v2)) eliminated.push([r, a.col]);
                                }
                            }
                            if (eliminated.length > 0) {
                                const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                return {
                                    type: 'Naked Pair',
                                    explanation: `Naked Pair [${v1},${v2}] in column ${a.col+1} at rows ${a.row+1} and ${b.row+1}. These cells must hold ${v1} and ${v2} ‚Äî eliminating both from ${elimStr}.`,
                                    cells: [[a.row, a.col], [b.row, b.col], ...eliminated],
                                    values: a.cands
                                };
                            }
                        }

                        // Same box?
                        const aBoxR = Math.floor(a.row / 2), aBoxC = Math.floor(a.col / 3);
                        const bBoxR = Math.floor(b.row / 2), bBoxC = Math.floor(b.col / 3);
                        if (aBoxR === bBoxR && aBoxC === bBoxC) {
                            const boxRow = aBoxR * 2, boxCol = aBoxC * 3;
                            const eliminated = [];
                            for (let bi = 0; bi < 2; bi++) {
                                for (let bj = 0; bj < 3; bj++) {
                                    const r = boxRow + bi, c = boxCol + bj;
                                    if ((r === a.row && c === a.col) || (r === b.row && c === b.col)) continue;
                                    if (grid[r][c] === 0) {
                                        const cands = this.getCandidates(grid, r, c);
                                        if (cands.includes(v1) || cands.includes(v2)) eliminated.push([r, c]);
                                    }
                                }
                            }
                            if (eliminated.length > 0) {
                                const boxNum = aBoxR * 2 + aBoxC + 1;
                                const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                return {
                                    type: 'Naked Pair',
                                    explanation: `Naked Pair [${v1},${v2}] in box ${boxNum} at (${a.row+1},${a.col+1}) and (${b.row+1},${b.col+1}). These cells must hold ${v1} and ${v2} ‚Äî eliminating both from ${elimStr}.`,
                                    cells: [[a.row, a.col], [b.row, b.col], ...eliminated],
                                    values: a.cands
                                };
                            }
                        }
                    }
                }
                return null;
            },

            findPointingPair(grid) {
                for (let boxIdx = 0; boxIdx < 6; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 2) * 2;
                    const boxCol = (boxIdx % 2) * 3;

                    for (let num = 1; num <= 6; num++) {
                        const positions = [];
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = boxRow + i;
                                const col = boxCol + j;
                                if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) {
                                    positions.push([row, col]);
                                }
                            }
                        }

                        if (positions.length >= 2 && positions.length <= 3) {
                            const sameRow = positions.every(([r]) => r === positions[0][0]);
                            if (sameRow) {
                                const targetRow = positions[0][0];
                                const eliminated = [];
                                for (let c = 0; c < 6; c++) {
                                    if (c >= boxCol && c < boxCol + 3) continue;
                                    if (grid[targetRow][c] === 0 && this.isValid(grid, targetRow, c, num)) eliminated.push([targetRow, c]);
                                }
                                if (eliminated.length > 0) {
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Pointing Pair',
                                        explanation: `In box ${boxIdx+1}, ${num} only appears in row ${targetRow+1}. So ${num} must land in this box's portion of that row ‚Äî eliminating ${num} from ${elimStr}.`,
                                        cells: [...positions, ...eliminated],
                                        value: num
                                    };
                                }
                            }

                            const sameCol = positions.every(([, c]) => c === positions[0][1]);
                            if (sameCol) {
                                const targetCol = positions[0][1];
                                const eliminated = [];
                                for (let r = 0; r < 6; r++) {
                                    if (r >= boxRow && r < boxRow + 2) continue;
                                    if (grid[r][targetCol] === 0 && this.isValid(grid, r, targetCol, num)) eliminated.push([r, targetCol]);
                                }
                                if (eliminated.length > 0) {
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Pointing Pair',
                                        explanation: `In box ${boxIdx+1}, ${num} only appears in column ${targetCol+1}. So ${num} must land in this box's portion of that column ‚Äî eliminating ${num} from ${elimStr}.`,
                                        cells: [...positions, ...eliminated],
                                        value: num
                                    };
                                }
                            }
                        }
                    }
                }
                return null;
            },

            findBoxLineReduction(grid) {
                for (let num = 1; num <= 6; num++) {
                    // Row-based: all candidates in a row fall within one box ‚Üí eliminate from rest of that box
                    for (let row = 0; row < 6; row++) {
                        const positions = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) positions.push([row, col]);
                        }
                        if (positions.length >= 2) {
                            const boxCols = positions.map(([, c]) => Math.floor(c / 3));
                            if (boxCols.every(bc => bc === boxCols[0])) {
                                const boxCol = boxCols[0] * 3;
                                const boxRow = Math.floor(row / 2) * 2;
                                const eliminated = [];
                                for (let i = 0; i < 2; i++) {
                                    const r = boxRow + i;
                                    if (r === row) continue;
                                    for (let j = 0; j < 3; j++) {
                                        const c = boxCol + j;
                                        if (grid[r][c] === 0 && this.isValid(grid, r, c, num)) eliminated.push([r, c]);
                                    }
                                }
                                if (eliminated.length > 0) {
                                    const boxNum = Math.floor(row / 2) * 2 + boxCols[0] + 1;
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Box/Line Reduction',
                                        explanation: `In row ${row+1}, ${num} is confined to box ${boxNum}. So ${num} must be placed within that box's row ‚Äî eliminating ${num} from the rest of box ${boxNum}: ${elimStr}.`,
                                        cells: [...positions, ...eliminated],
                                        value: num
                                    };
                                }
                            }
                        }
                    }
                    // Column-based: all candidates in a column fall within one box ‚Üí eliminate from rest of that box
                    for (let col = 0; col < 6; col++) {
                        const positions = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) positions.push([row, col]);
                        }
                        if (positions.length >= 2) {
                            const boxRows = positions.map(([r]) => Math.floor(r / 2));
                            if (boxRows.every(br => br === boxRows[0])) {
                                const boxRow = boxRows[0] * 2;
                                const boxCol = Math.floor(col / 3) * 3;
                                const eliminated = [];
                                for (let i = 0; i < 2; i++) {
                                    for (let j = 0; j < 3; j++) {
                                        const r = boxRow + i, c = boxCol + j;
                                        if (c === col) continue;
                                        if (grid[r][c] === 0 && this.isValid(grid, r, c, num)) eliminated.push([r, c]);
                                    }
                                }
                                if (eliminated.length > 0) {
                                    const boxNum = boxRows[0] * 2 + Math.floor(col / 3) + 1;
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Box/Line Reduction',
                                        explanation: `In column ${col+1}, ${num} is confined to box ${boxNum}. So ${num} must be placed within that box's column ‚Äî eliminating ${num} from the rest of box ${boxNum}: ${elimStr}.`,
                                        cells: [...positions, ...eliminated],
                                        value: num
                                    };
                                }
                            }
                        }
                    }
                }
                return null;
            },

            findXWing(grid) {
                for (let num = 1; num <= 6; num++) {
                    // Row-based: num appears exactly twice in two rows, in the same two columns
                    const rowPairs = [];
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) cols.push(col);
                        }
                        if (cols.length === 2) rowPairs.push({ row, cols });
                    }
                    for (let i = 0; i < rowPairs.length; i++) {
                        for (let j = i + 1; j < rowPairs.length; j++) {
                            if (rowPairs[i].cols[0] !== rowPairs[j].cols[0] ||
                                rowPairs[i].cols[1] !== rowPairs[j].cols[1]) continue;
                            const r0 = rowPairs[i].row, r1 = rowPairs[j].row;
                            const c0 = rowPairs[i].cols[0], c1 = rowPairs[i].cols[1];
                            const eliminated = [];
                            for (let r = 0; r < 6; r++) {
                                if (r === r0 || r === r1) continue;
                                if (grid[r][c0] === 0 && this.isValid(grid, r, c0, num)) eliminated.push([r, c0]);
                                if (grid[r][c1] === 0 && this.isValid(grid, r, c1, num)) eliminated.push([r, c1]);
                            }
                            if (eliminated.length === 0) continue;
                            const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                            return {
                                type: 'X-Wing',
                                explanation: `X-Wing on ${num}: it can only go in columns ${c0+1} and ${c1+1} within rows ${r0+1} and ${r1+1}, locking ${num} to those columns. This eliminates ${num} from ${elimStr}.`,
                                cells: [
                                    [r0, c0], [r0, c1], [r1, c0], [r1, c1],
                                    ...eliminated
                                ],
                                value: num
                            };
                        }
                    }
                    // Column-based: num appears exactly twice in two columns, in the same two rows
                    const colPairs = [];
                    for (let col = 0; col < 6; col++) {
                        const rows = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) rows.push(row);
                        }
                        if (rows.length === 2) colPairs.push({ col, rows });
                    }
                    for (let i = 0; i < colPairs.length; i++) {
                        for (let j = i + 1; j < colPairs.length; j++) {
                            if (colPairs[i].rows[0] !== colPairs[j].rows[0] ||
                                colPairs[i].rows[1] !== colPairs[j].rows[1]) continue;
                            const r0 = colPairs[i].rows[0], r1 = colPairs[i].rows[1];
                            const c0 = colPairs[i].col, c1 = colPairs[j].col;
                            const eliminated = [];
                            for (let c = 0; c < 6; c++) {
                                if (c === c0 || c === c1) continue;
                                if (grid[r0][c] === 0 && this.isValid(grid, r0, c, num)) eliminated.push([r0, c]);
                                if (grid[r1][c] === 0 && this.isValid(grid, r1, c, num)) eliminated.push([r1, c]);
                            }
                            if (eliminated.length === 0) continue;
                            const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                            return {
                                type: 'X-Wing',
                                explanation: `X-Wing on ${num}: it can only go in rows ${r0+1} and ${r1+1} within columns ${c0+1} and ${c1+1}, locking ${num} to those rows. This eliminates ${num} from ${elimStr}.`,
                                cells: [
                                    [r0, c0], [r0, c1], [r1, c0], [r1, c1],
                                    ...eliminated
                                ],
                                value: num
                            };
                        }
                    }
                }
                return null;
            },

            findYWing(grid) {
                // Two cells "see" each other if they share a row, column, or 2√ó3 box
                const sees = (r1, c1, r2, c2) => {
                    if (r1 === r2 || c1 === c2) return true;
                    return Math.floor(r1 / 2) === Math.floor(r2 / 2) &&
                           Math.floor(c1 / 3) === Math.floor(c2 / 3);
                };

                const biValueCells = [];
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) biValueCells.push({ row, col, cands });
                        }
                    }
                }

                for (let i = 0; i < biValueCells.length; i++) {
                    const pivot = biValueCells[i];
                    for (let j = 0; j < biValueCells.length; j++) {
                        if (i === j) continue;
                        const wing1 = biValueCells[j];
                        // Pivot must see wing1
                        if (!sees(pivot.row, pivot.col, wing1.row, wing1.col)) continue;
                        const shared1 = pivot.cands.filter(c => wing1.cands.includes(c));
                        if (shared1.length !== 1) continue;

                        for (let k = 0; k < biValueCells.length; k++) {
                            if (k === i || k === j) continue;
                            const wing2 = biValueCells[k];
                            // Pivot must see wing2
                            if (!sees(pivot.row, pivot.col, wing2.row, wing2.col)) continue;
                            const shared2 = pivot.cands.filter(c => wing2.cands.includes(c));
                            if (shared2.length !== 1) continue;
                            // Wings must share different candidates with the pivot
                            if (shared2[0] === shared1[0]) continue;

                            const sharedBetweenWings = wing1.cands.filter(c => wing2.cands.includes(c));
                            if (sharedBetweenWings.length !== 1) continue;
                            const pincerVal = sharedBetweenWings[0];

                            // Find cells that see BOTH wings and still have pincerVal as a candidate
                            const eliminated = [];
                            for (let r = 0; r < 6; r++) {
                                for (let c = 0; c < 6; c++) {
                                    if ((r === pivot.row && c === pivot.col) ||
                                        (r === wing1.row && c === wing1.col) ||
                                        (r === wing2.row && c === wing2.col)) continue;
                                    if (grid[r][c] === 0 &&
                                        sees(r, c, wing1.row, wing1.col) &&
                                        sees(r, c, wing2.row, wing2.col) &&
                                        this.isValid(grid, r, c, pincerVal)) {
                                        eliminated.push([r, c]);
                                    }
                                }
                            }
                            if (eliminated.length === 0) continue;

                            const [A, B] = pivot.cands;
                            const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                            return {
                                type: 'Y-Wing',
                                explanation: `Y-Wing: Pivot (${pivot.row+1},${pivot.col+1}) [${A},${B}] sees wing (${wing1.row+1},${wing1.col+1}) [${wing1.cands.join(',')}] and wing (${wing2.row+1},${wing2.col+1}) [${wing2.cands.join(',')}]. Whichever value the pivot takes, ${pincerVal} is forced into one of the wings ‚Äî eliminating ${pincerVal} from ${elimStr}.`,
                                cells: [
                                    [pivot.row, pivot.col],
                                    [wing1.row, wing1.col],
                                    [wing2.row, wing2.col],
                                    ...eliminated
                                ],
                                value: pincerVal
                            };
                        }
                    }
                }
                return null;
            },

            // BUG+1 (Bivalue Universal Grave) - if all unsolved cells have 2 candidates
            // except one cell with 3, that cell's extra candidate is the answer
            findBUG(grid) {
                let triValueCell = null;

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (grid[row][col] === 0) {
                            const cands = this.getCandidates(grid, row, col);
                            if (cands.length === 2) {
                                // fine
                            } else if (cands.length === 3) {
                                if (triValueCell) return null; // More than one 3-candidate cell
                                triValueCell = { row, col, cands };
                            } else {
                                return null; // Cell with 1 or 4+ candidates breaks BUG pattern
                            }
                        }
                    }
                }

                if (!triValueCell) return null;

                // The BUG candidate must appear an odd number of times in ALL three of
                // its units (row, column, box). Using AND catches only genuine BUG+1 states.
                for (const cand of triValueCell.cands) {
                    let rowCount = 0;
                    for (let c = 0; c < 6; c++) {
                        if (grid[triValueCell.row][c] === 0 &&
                            this.getCandidates(grid, triValueCell.row, c).includes(cand)) rowCount++;
                    }
                    let colCount = 0;
                    for (let r = 0; r < 6; r++) {
                        if (grid[r][triValueCell.col] === 0 &&
                            this.getCandidates(grid, r, triValueCell.col).includes(cand)) colCount++;
                    }
                    const boxRow = Math.floor(triValueCell.row / 2) * 2;
                    const boxCol = Math.floor(triValueCell.col / 3) * 3;
                    let boxCount = 0;
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 3; j++) {
                            const r = boxRow + i, c = boxCol + j;
                            if (grid[r][c] === 0 &&
                                this.getCandidates(grid, r, c).includes(cand)) boxCount++;
                        }
                    }

                    if (rowCount % 2 === 1 && colCount % 2 === 1 && boxCount % 2 === 1) {
                        return {
                            type: 'BUG+1',
                            row: triValueCell.row,
                            col: triValueCell.col,
                            value: cand,
                            explanation: `BUG+1: Every unsolved cell has exactly 2 candidates except (${triValueCell.row+1},${triValueCell.col+1}) which has 3. If ${cand} weren't placed here, all remaining cells would have 2 candidates ‚Äî creating a deadly pattern with two solutions. Therefore ${cand} must go in (${triValueCell.row+1},${triValueCell.col+1}).`,
                            cells: [[triValueCell.row, triValueCell.col]]
                        };
                    }
                }
                return null;
            },

            // Swordfish - like X-Wing but with 3 rows/columns
            findSwordfish(grid) {
                for (let num = 1; num <= 6; num++) {
                    // Row-based: 3 rows where num is confined to the same 3 columns
                    const rowData = [];
                    for (let row = 0; row < 6; row++) {
                        const cols = [];
                        for (let col = 0; col < 6; col++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) cols.push(col);
                        }
                        if (cols.length >= 2 && cols.length <= 3) rowData.push({ row, cols });
                    }
                    if (rowData.length >= 3) {
                        for (let i = 0; i < rowData.length - 2; i++) {
                            for (let j = i + 1; j < rowData.length - 1; j++) {
                                for (let k = j + 1; k < rowData.length; k++) {
                                    const allCols = new Set([...rowData[i].cols, ...rowData[j].cols, ...rowData[k].cols]);
                                    if (allCols.size !== 3) continue;
                                    const sfRows = [rowData[i].row, rowData[j].row, rowData[k].row];
                                    const sfCols = [...allCols];
                                    const eliminated = [];
                                    for (let r = 0; r < 6; r++) {
                                        if (sfRows.includes(r)) continue;
                                        for (const c of sfCols) {
                                            if (grid[r][c] === 0 && this.isValid(grid, r, c, num)) eliminated.push([r, c]);
                                        }
                                    }
                                    if (eliminated.length === 0) continue;
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Swordfish',
                                        explanation: `Swordfish on ${num}: in rows ${sfRows.map(r => r+1).join(', ')}, ${num} only appears in columns ${sfCols.map(c => c+1).join(', ')}. This locks ${num} to those columns ‚Äî eliminating ${num} from ${elimStr}.`,
                                        cells: [
                                            ...rowData[i].cols.map(c => [rowData[i].row, c]),
                                            ...rowData[j].cols.map(c => [rowData[j].row, c]),
                                            ...rowData[k].cols.map(c => [rowData[k].row, c]),
                                            ...eliminated
                                        ],
                                        value: num
                                    };
                                }
                            }
                        }
                    }
                    // Column-based: 3 columns where num is confined to the same 3 rows
                    const colData = [];
                    for (let col = 0; col < 6; col++) {
                        const rows = [];
                        for (let row = 0; row < 6; row++) {
                            if (grid[row][col] === 0 && this.isValid(grid, row, col, num)) rows.push(row);
                        }
                        if (rows.length >= 2 && rows.length <= 3) colData.push({ col, rows });
                    }
                    if (colData.length >= 3) {
                        for (let i = 0; i < colData.length - 2; i++) {
                            for (let j = i + 1; j < colData.length - 1; j++) {
                                for (let k = j + 1; k < colData.length; k++) {
                                    const allRows = new Set([...colData[i].rows, ...colData[j].rows, ...colData[k].rows]);
                                    if (allRows.size !== 3) continue;
                                    const sfCols = [colData[i].col, colData[j].col, colData[k].col];
                                    const sfRows = [...allRows];
                                    const eliminated = [];
                                    for (let c = 0; c < 6; c++) {
                                        if (sfCols.includes(c)) continue;
                                        for (const r of sfRows) {
                                            if (grid[r][c] === 0 && this.isValid(grid, r, c, num)) eliminated.push([r, c]);
                                        }
                                    }
                                    if (eliminated.length === 0) continue;
                                    const elimStr = eliminated.map(([r, c]) => `(${r+1},${c+1})`).join(', ');
                                    return {
                                        type: 'Swordfish',
                                        explanation: `Swordfish on ${num}: in columns ${sfCols.map(c => c+1).join(', ')}, ${num} only appears in rows ${sfRows.map(r => r+1).join(', ')}. This locks ${num} to those rows ‚Äî eliminating ${num} from ${elimStr}.`,
                                        cells: [
                                            ...colData[i].rows.map(r => [r, colData[i].col]),
                                            ...colData[j].rows.map(r => [r, colData[j].col]),
                                            ...colData[k].rows.map(r => [r, colData[k].col]),
                                            ...eliminated
                                        ],
                                        value: num
                                    };
                                }
                            }
                        }
                    }
                }
                return null;
            },

            handleNewGame() {
                if (this.currentMode === 'archive') {
                    this.backToArchive();
                } else {
                    this.newPuzzle();
                }
            },

            newPuzzle() {
                this.currentMode = 'random';
                this.currentLevelId = null;
                document.querySelector('.top-bar h1').textContent = 'Mini Sudoku';

                const { puzzle, solution } = this.generatePuzzle(this.difficulty);

                // Verify the puzzle is valid
                console.log('Generated puzzle:', puzzle);
                console.log('Solution:', solution);
                console.log('Difficulty:', this.difficulty);

                this.grid = puzzle.map(row => [...row]);
                this.initialGrid = puzzle.map(row => [...row]);
                this.solution = solution;
                this.selectedCell = null;
                this.notes = {};
                this.history = [];
                this.solveAttempts = [];
                this.timer = 0;
                this.isRunning = true;
                this.currentHint = null;
                this.highlightedCells = [];
                this.startTimer();
                this.render();
                this.hideMessage();
                this.updateTimerButton();
                document.getElementById('newGameBtn').classList.remove('show');
            },

            changeDifficulty(newDifficulty) {
                this.difficulty = newDifficulty;
                localStorage.setItem('sudokuDifficulty', newDifficulty);
                this.updateSettingsUI();
            },

            toggleTactic(key) {
                this.enabledTactics[key] = !this.enabledTactics[key];
                this.saveTactics();
                this.updateSettingsUI();
            },

            // Settings Modal
            openSettings() {
                this.updateSettingsUI();
                document.getElementById('settingsModal').classList.add('show');
            },

            closeSettings() {
                document.getElementById('settingsModal').classList.remove('show');
            },

            closeSettingsOnOverlay(event) {
                if (event.target === event.currentTarget) {
                    this.closeSettings();
                }
            },

            newPuzzleFromSettings() {
                this.closeSettings();
                this.newPuzzle();
            },

            updateSettingsUI() {
                // Update difficulty buttons
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.difficulty);
                });
                // Update hint buttons
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === this.hintLevel);
                });
                // Update tactic buttons
                document.querySelectorAll('#tacticsOptions .tactic-btn').forEach(btn => {
                    btn.classList.toggle('active', !!this.enabledTactics[btn.dataset.tactic]);
                });
                // Update timer button
                this.updateTimerButton();
            },

            updateTimerButton() {
                const btn = document.getElementById('timerToggleBtn');
                const text = document.getElementById('timerBtnText');
                if (btn && text) {
                    text.textContent = this.isRunning ? 'Pause' : 'Resume';
                    btn.classList.toggle('active', !this.isRunning);
                }
            },

            initSettingsListeners() {
                // Difficulty options
                document.querySelectorAll('#difficultyOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.changeDifficulty(btn.dataset.value);
                    });
                });
                // Hint options
                document.querySelectorAll('#hintOptions .option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setHintLevel(btn.dataset.value);
                    });
                });
                // Tactic toggle buttons
                document.querySelectorAll('#tacticsOptions .tactic-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.toggleTactic(btn.dataset.tactic));
                });
            },

            startTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if (this.isRunning) {
                        this.timer++;
                        this.updateTimer();
                    }
                }, 1000);
            },

            toggleTimer() {
                this.isRunning = !this.isRunning;
                this.updateTimerButton();

                // Add/remove blur effect
                const grid = document.getElementById('grid');
                if (this.isRunning) {
                    grid.classList.remove('blurred');
                } else {
                    grid.classList.add('blurred');
                }
            },

            updateTimer() {
                const mins = Math.floor(this.timer / 60);
                const secs = this.timer % 60;
                document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            },

            toggleNotes() {
                this.mode = this.mode === 'normal' ? 'notes' : 'normal';
                const notesBtn = document.getElementById('notesBtn');
                const notesStatus = document.getElementById('notesStatus');
                if (this.mode === 'notes') {
                    notesBtn.classList.add('active');
                    if (notesStatus) notesStatus.textContent = 'ON';
                } else {
                    notesBtn.classList.remove('active');
                    if (notesStatus) notesStatus.textContent = 'OFF';
                }
            },

            setHintLevel(level) {
                this.hintLevel = level;
                this.updateSettingsUI();
            },

            selectCell(row, col) {
                this.selectedCell = [row, col];
                this.render();
            },

            checkUnitComplete(row, col) {
                // Check if a row matches the solution
                const checkRow = (r) => {
                    for (let c = 0; c < 6; c++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a column matches the solution
                const checkCol = (c) => {
                    for (let r = 0; r < 6; r++) {
                        if (this.grid[r][c] !== this.solution[r][c]) return false;
                    }
                    return true;
                };

                // Check if a box matches the solution
                const checkBox = (r, c) => {
                    const boxRow = Math.floor(r / 2) * 2;
                    const boxCol = Math.floor(c / 3) * 3;
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 3; j++) {
                            const br = boxRow + i;
                            const bc = boxCol + j;
                            if (this.grid[br][bc] !== this.solution[br][bc]) return false;
                        }
                    }
                    return true;
                };

                const completedUnits = [];

                // Check row
                if (checkRow(row)) {
                    completedUnits.push({ type: 'row', index: row });
                }

                // Check column
                if (checkCol(col)) {
                    completedUnits.push({ type: 'col', index: col });
                }

                // Check box
                if (checkBox(row, col)) {
                    const boxRow = Math.floor(row / 2) * 2;
                    const boxCol = Math.floor(col / 3) * 3;
                    completedUnits.push({ type: 'box', boxRow, boxCol });
                }

                // Animate completed units
                if (completedUnits.length > 0) {
                    this.animateCompletions(completedUnits);
                }
            },

            animateCompletions(units) {
                const cells = document.querySelectorAll('.cell');
                
                units.forEach(unit => {
                    if (unit.type === 'row') {
                        // Animate entire row
                        for (let col = 0; col < 6; col++) {
                            const cellIndex = unit.index * 6 + col;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'col') {
                        // Animate entire column
                        for (let row = 0; row < 6; row++) {
                            const cellIndex = row * 6 + unit.index;
                            cells[cellIndex].classList.add('complete-flash');
                            setTimeout(() => {
                                cells[cellIndex].classList.remove('complete-flash');
                            }, 600);
                        }
                    } else if (unit.type === 'box') {
                        // Animate entire box
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = unit.boxRow + i;
                                const col = unit.boxCol + j;
                                const cellIndex = row * 6 + col;
                                cells[cellIndex].classList.add('complete-flash');
                                setTimeout(() => {
                                    cells[cellIndex].classList.remove('complete-flash');
                                }, 600);
                            }
                        }
                    }
                });
            },

            inputNumber(num) {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                if (this.mode === 'normal') {
                    // Save to history for undo
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: num,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });

                    this.grid[row][col] = num;
                    this.solveAttempts.push({ t: this.timer, correct: num === this.solution[row][col] });
                    delete this.notes[`${row}-${col}`];
                    this.render();
                    
                    // Check for completed units AFTER rendering
                    setTimeout(() => {
                        this.checkUnitComplete(row, col);
                        this.checkComplete();
                    }, 50);
                } else {
                    const key = `${row}-${col}`;
                    const cellNotes = this.notes[key] || [];
                    if (cellNotes.includes(num)) {
                        this.notes[key] = cellNotes.filter(n => n !== num);
                        if (this.notes[key].length === 0) delete this.notes[key];
                    } else {
                        this.notes[key] = [...cellNotes, num].sort();
                    }
                    this.render();
                }
            },

            undo() {
                if (this.history.length === 0) {
                    this.showMessage('Nothing to undo', 'info');
                    setTimeout(() => this.hideMessage(), 1500);
                    return;
                }

                const lastMove = this.history.pop();
                this.grid[lastMove.row][lastMove.col] = lastMove.oldValue;
                
                if (lastMove.oldNotes) {
                    this.notes[`${lastMove.row}-${lastMove.col}`] = lastMove.oldNotes;
                } else {
                    delete this.notes[`${lastMove.row}-${lastMove.col}`];
                }

                this.selectedCell = [lastMove.row, lastMove.col];
                this.render();
            },

            clearCell() {
                if (!this.selectedCell) return;
                const [row, col] = this.selectedCell;
                if (this.initialGrid[row][col] !== 0) return;

                // Save to history for undo
                if (this.grid[row][col] !== 0) {
                    this.history.push({
                        row,
                        col,
                        oldValue: this.grid[row][col],
                        newValue: 0,
                        oldNotes: this.notes[`${row}-${col}`] ? [...this.notes[`${row}-${col}`]] : null
                    });
                }

                this.grid[row][col] = 0;
                delete this.notes[`${row}-${col}`];
                this.render();
            },

            getHint() {
                const hint = this.getSmartHint(this.grid);
                if (!hint) {
                    this.showMessage('No hints available!', 'info');
                    return;
                }

                this.currentHint = hint;
                this.highlightedCells = hint.cells || [];

                let message = '';
                if (this.hintLevel === 'strategy') {
                    message = `üí° Try: ${hint.type}`;
                } else if (this.hintLevel === 'location') {
                    message = `üí° ${hint.type}: Look at row ${hint.row + 1}, column ${hint.col + 1}`;
                } else {
                    message = `üí° ${hint.type}: ${hint.explanation}`;
                }

                this.showMessage(message, 'info');
                this.render();

                setTimeout(() => {
                    this.highlightedCells = [];
                    this.render();
                }, 5000);
            },

            applyHint() {
                if (!this.currentHint || this.currentHint.value === null) {
                    this.showMessage('Get a hint first!', 'info');
                    return;
                }

                this.grid[this.currentHint.row][this.currentHint.col] = this.currentHint.value;
                this.currentHint = null;
                this.highlightedCells = [];
                this.checkComplete();
                this.render();
                this.showMessage('Hint applied!', 'success');
                setTimeout(() => this.hideMessage(), 2000);
            },

            solveAll() {
                this.grid = this.solution.map(row => [...row]);
                this.isRunning = false;
                this.render();
                this.showMessage('Puzzle solved!', 'success');
            },

            applyHintFromSettings() {
                this.closeSettings();
                this.applyHint();
            },

            solveAllFromSettings() {
                this.closeSettings();
                this.solveAll();
            },

            checkComplete() {
                const isFilled = this.grid.every(row => row.every(cell => cell !== 0));
                if (isFilled) {
                    const isCorrect = this.grid.every((row, i) =>
                        row.every((cell, j) => cell === this.solution[i][j])
                    );
                    if (isCorrect) {
                        this.isRunning = false;
                        this.openSolveStats();
                        const timeStr = this.formatTime(this.timer);

                        if (this.currentMode === 'archive') {
                            // Archive mode completion
                            const progress = this.archiveProgress[this.currentLevelId];
                            const isNewRecord = !progress || !progress.bestTime || this.timer < progress.bestTime;

                            if (isNewRecord) {
                                this.archiveProgress[this.currentLevelId] = {
                                    bestTime: this.timer,
                                    completedAt: new Date().toISOString()
                                };
                                this.saveArchiveProgress();
                            }

                            let message = `üéâ Solved in ${timeStr}!`;
                            if (isNewRecord && progress && progress.bestTime) {
                                message += ' New Record!';
                            }
                            this.showMessage(message, 'success');

                            // Update button text for archive mode
                            const btn = document.getElementById('newGameBtn');
                            btn.textContent = 'Back to Levels';
                            btn.onclick = () => this.backToArchive();
                            btn.classList.add('show');
                        } else {
                            // Random mode completion
                            const correctInputs = this.solveAttempts.filter(a => a.correct).length;
                            const cspm = this.timer > 0 ? Math.round((correctInputs / this.timer) * 60 * 10) / 10 : 0;
                            this.trackGameComplete(this.difficulty, this.timer, cspm);

                            const avg = this.getAverageTime(this.difficulty);
                            let message = `üéâ Solved in ${timeStr}!`;
                            if (avg) {
                                const diff = this.timer - avg;
                                const diffStr = this.formatTime(Math.abs(diff));
                                if (diff < 0) {
                                    message += ` (${diffStr} faster than avg)`;
                                } else if (diff > 0) {
                                    message += ` (${diffStr} slower than avg)`;
                                }
                            }
                            this.showMessage(message, 'success');

                            const btn = document.getElementById('newGameBtn');
                            btn.textContent = 'New Game';
                            btn.onclick = () => this.newPuzzle();
                            btn.classList.add('show');
                        }
                    } else {
                        this.showMessage('Some cells are incorrect!', 'error');
                        setTimeout(() => this.hideMessage(), 3000);
                    }
                }
            },

            showMessage(text, type) {
                const msg = document.getElementById('message');
                msg.textContent = text;
                msg.className = `message ${type}`;
                msg.style.display = 'block';
            },

            hideMessage() {
                document.getElementById('message').style.display = 'none';
            },

            showInstallInstructions() {
                // Check if already installed or dismissed
                if (window.matchMedia('(display-mode: standalone)').matches) {
                    return; // Already installed
                }

                if (localStorage.getItem('installBannerDismissed')) {
                    return; // User dismissed it
                }

                const banner = document.getElementById('installBanner');
                const instructions = document.getElementById('installInstructions');
                
                // Detect platform
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    instructions.innerHTML = 'üçé Safari: Tap <strong>Share</strong> ‚Üí <strong>Add to Home Screen</strong>';
                    banner.style.display = 'block';
                } else if (isAndroid) {
                    instructions.innerHTML = 'ü§ñ Chrome: Tap <strong>‚ãÆ</strong> menu ‚Üí <strong>Add to Home screen</strong>';
                    banner.style.display = 'block';
                } else {
                    // Desktop or other browsers
                    instructions.innerHTML = 'üíª Install this app for quick access!';
                    banner.style.display = 'block';
                }
            },

            dismissInstallBanner() {
                document.getElementById('installBanner').style.display = 'none';
                localStorage.setItem('installBannerDismissed', 'true');
            },

            // Check if a cell has a conflict (duplicate in row, column, or box)
            hasConflict(row, col) {
                const num = this.grid[row][col];
                if (num === 0) return false;

                // Check row for duplicates
                for (let c = 0; c < 6; c++) {
                    if (c !== col && this.grid[row][c] === num) return true;
                }

                // Check column for duplicates
                for (let r = 0; r < 6; r++) {
                    if (r !== row && this.grid[r][col] === num) return true;
                }

                // Check 2x3 box for duplicates
                const boxRow = Math.floor(row / 2) * 2;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        const r = boxRow + i;
                        const c = boxCol + j;
                        if ((r !== row || c !== col) && this.grid[r][c] === num) return true;
                    }
                }

                return false;
            },

            render() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 6; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';

                        const isGiven = this.initialGrid[row][col] !== 0;
                        const isSelected = this.selectedCell && this.selectedCell[0] === row && this.selectedCell[1] === col;
                        const isHighlighted = this.highlightedCells.some(([r, c]) => r === row && c === col);
                        const isConflict = this.hasConflict(row, col);

                        if (isGiven) cell.classList.add('given');
                        if (isSelected) cell.classList.add('selected');
                        if (isHighlighted) cell.classList.add('highlighted');
                        if (!isGiven && this.grid[row][col] !== 0) cell.classList.add('user-input');
                        if (isConflict) cell.classList.add('conflict');

                        const key = `${row}-${col}`;
                        const cellNotes = this.notes[key] || [];

                        if (cellNotes.length > 0 && this.grid[row][col] === 0) {
                            const notesDiv = document.createElement('div');
                            notesDiv.className = 'notes';
                            for (let num = 1; num <= 6; num++) {
                                const noteEl = document.createElement('div');
                                noteEl.className = 'note';
                                noteEl.textContent = cellNotes.includes(num) ? num : '';
                                notesDiv.appendChild(noteEl);
                            }
                            cell.appendChild(notesDiv);
                        } else if (this.grid[row][col] !== 0) {
                            cell.textContent = this.grid[row][col];
                        }

                        cell.onclick = () => this.selectCell(row, col);
                        gridEl.appendChild(cell);
                    }
                }
                if (this.solution && this.solution.length) {
                    this.updateNumberPadState();
                }
            },

            updateNumberPadState() {
                const solutionCount = {};
                const gridCount = {};
                for (let num = 1; num <= 6; num++) {
                    solutionCount[num] = 0;
                    gridCount[num] = 0;
                }
                for (let r = 0; r < 6; r++) {
                    for (let c = 0; c < 6; c++) {
                        const s = this.solution[r][c];
                        const g = this.grid[r][c];
                        if (s) solutionCount[s]++;
                        if (g) gridCount[g]++;
                    }
                }
                document.querySelectorAll('.number-pad .number-btn:not(.action)').forEach(btn => {
                    const num = parseInt(btn.textContent.trim());
                    const done = gridCount[num] >= solutionCount[num];
                    btn.classList.toggle('completed', done);
                    btn.disabled = done;
                });
            }
        };

        window.onload = () => {
            app.init();

            // Show install instructions based on platform
            app.showInstallInstructions();

            // Keyboard input support
            document.addEventListener('keydown', (e) => {
                // Escape to close modals
                if (e.key === 'Escape') {
                    app.closeSettings();
                    app.closeStats();
                    app.closeSolveStats();
                    return;
                }
                // Don't handle other keys if modal is open
                if (document.getElementById('settingsModal').classList.contains('show') ||
                    document.getElementById('statsModal').classList.contains('show') ||
                    document.getElementById('solveStatsModal').classList.contains('show')) {
                    return;
                }
                // Number keys 1-6
                if (e.key >= '1' && e.key <= '6') {
                    app.inputNumber(parseInt(e.key));
                }
                // Backspace or Delete to clear
                else if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    app.clearCell();
                }
                // Arrow keys for navigation
                else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!app.selectedCell) {
                        app.selectCell(0, 0);
                    } else {
                        let [row, col] = app.selectedCell;
                        if (e.key === 'ArrowUp') row = Math.max(0, row - 1);
                        else if (e.key === 'ArrowDown') row = Math.min(5, row + 1);
                        else if (e.key === 'ArrowLeft') col = Math.max(0, col - 1);
                        else if (e.key === 'ArrowRight') col = Math.min(5, col + 1);
                        app.selectCell(row, col);
                    }
                }
                // N key to toggle notes mode
                else if (e.key === 'n' || e.key === 'N') {
                    app.toggleNotes();
                }
                // H key for hint
                else if (e.key === 'h' || e.key === 'H') {
                    app.getHint();
                }
                // Z key for undo (Ctrl/Cmd+Z)
                else if ((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    app.undo();
                }
            });

            // Register service worker for PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('Service Worker registered', reg))
                    .catch(err => console.log('Service Worker registration failed', err));
            }
        };
    </script>
</body>
</html>
